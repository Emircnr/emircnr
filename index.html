<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Global RTS — Üs Kur, Üret, Saldır!</title>

  <!-- MAP & UI LIBS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0b1220; --panel:#111A2B; --panel2:#0F1626; --accent:#34d399; --accent2:#60a5fa; --danger:#ef4444; --warning:#f59e0b; --text:#E6EDF6;
    }
    html,body{height:100%; background:var(--bg); color:var(--text); font-family:'Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}
    #app{height:100%; display:grid; grid-template-rows:auto 1fr auto}
    #map{height:100%; width:100%}

    /* HUD */
    .glass{backdrop-filter: blur(10px); background: linear-gradient(180deg, rgba(17,26,43,.8), rgba(11,18,32,.8)); border:1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.35)}
    .btn{display:inline-flex; align-items:center; gap:.5rem; padding:.5rem .8rem; border-radius:.75rem; border:1px solid rgba(255,255,255,.06); transition:.2s transform, .2s background, .2s border}
    .btn:hover{transform:translateY(-1px); border-color: rgba(255,255,255,.12)}
    .btn:active{transform:translateY(0)}
    .btn[disabled]{opacity:.45; pointer-events:none}

    .tag{font-size:.75rem; padding:.15rem .5rem; border-radius:.4rem; border:1px solid rgba(255,255,255,.1)}

    /* Marker icons via DIVs so we can style/animate */
    .unit, .building{ position:relative; display:flex; align-items:center; justify-content:center; font-weight:800; color:#fff; border-radius:999px; border:2px solid rgba(0,0,0,.3); box-shadow:0 8px 20px rgba(0,0,0,.35)}
    .unit{ width:22px; height:22px; font-size:12px }
    .building{ width:28px; height:28px; font-size:14px }
    .player{ background: radial-gradient(circle at 30% 30%, #10b981 10%, #059669 80%) }
    .ai{ background: radial-gradient(circle at 30% 30%, #60a5fa 10%, #2563eb 80%) }
    .neutral{ background: #6b7280 }
    .kepce::after{ content:"⛏️"; filter: drop-shadow(0 1px 0 rgba(0,0,0,.5)); }
    .soldier::after{ content:"🪖" }
    .tank::after{ content:"🛡️" }
    .base::after{ content:"🏰" }
    .mill::after{ content:"🌾" }
    .refinery::after{ content:"🛢️" }
    .port::after{ content:"⚓" }
    .factory::after{ content:"🏭" }
    .barracks::after{ content:"🎖️" }

    /* Selection ring */
    .sel{ outline:3px solid rgba(255,255,255,.7); outline-offset:2px; animation:pulse 1.2s ease-in-out infinite }
    @keyframes pulse{ 0%{outline-color:rgba(255,255,255,.7)} 50%{outline-color:rgba(255,255,255,.2)} 100%{outline-color:rgba(255,255,255,.7)} }

    /* Healthbar */
    .hpbar{ position:absolute; bottom:-4px; left: 50%; width: 44px; height:3px; background:rgba(255,255,255,.15); border-radius: 999px; overflow:hidden; transform: translateX(-50%)}
    .hpfill{ height:100%; background: linear-gradient(90deg, #22c55e, #16a34a) }

    /* Build progress bar */
    .buildbar{ position:absolute; top:-6px; left:50%; width:44px; height:4px; background:rgba(255,255,255,.1); border-radius:999px; overflow:hidden; transform: translateX(-50%);}    
    .buildfill{ height:100%; background: linear-gradient(90deg, #f59e0b, #fde047) }

    /* Attack beam */
    .beam{ stroke:#fef08a; stroke-width:2; stroke-linecap:round; filter: drop-shadow(0 0 6px rgba(250,204,21,.9)); opacity:.95; pointer-events:none }

    /* Modal */
    .modal{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.5); z-index:9999 }
    .modal.show{ display:grid }

    /* Leaflet tweaks */
    .leaflet-container{ background:#0b1220 }
    .leaflet-control-zoom{ border:none }
    .leaflet-bar a{ background:var(--panel); color:#fff; border:none }
    .leaflet-bar a:hover{ background:#1b2741 }
  </style>
</head>
<body>
<div id="app">
  <!-- TOP HUD -->
  <header class="glass z-[5000] sticky top-0 w-full">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-wrap gap-3 items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="text-xl font-extrabold tracking-wide">GLOBAL <span class="text-emerald-400">RTS</span></div>
        <div class="hidden md:flex items-center gap-2 text-sm opacity-80">
          <span class="tag bg-emerald-500/10 border-emerald-400/30">Gerçek Dünya Haritası</span>
          <span class="tag bg-sky-500/10 border-sky-400/30">Canlı Savaş</span>
          <span class="tag bg-yellow-500/10 border-yellow-400/30">AI Rakip</span>
        </div>
      </div>
      <div class="flex flex-wrap gap-3 items-center">
        <div class="glass rounded-xl px-3 py-2 flex items-center gap-5 text-sm">
          <div class="flex items-center gap-1"><span class="opacity-70">💰 Para:</span> <span id="money" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🛢️ Petrol:</span> <span id="oil" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🔧 Kepçe:</span> <span id="excCount" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🪖 Asker:</span> <span id="soldierCount" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🛡️ Tank:</span> <span id="tankCount" class="font-bold">0</span></div>
        </div>
        <div class="glass rounded-xl px-3 py-2 text-xs flex items-center gap-2">
          <span>⏩ Hız:</span>
          <input id="speedRange" type="range" min="1" max="100" value="1" class="w-32"/>
          <span id="speedLbl" class="font-bold">1x</span>
          <div class="hidden sm:flex items-center gap-1 ml-2">
            <button class="btn bg-white/10" data-speed="1">1x</button>
            <button class="btn bg-white/10" data-speed="2">2x</button>
            <button class="btn bg-white/10" data-speed="5">5x</button>
            <button class="btn bg-white/10" data-speed="10">10x</button>
            <button class="btn bg-white/10" data-speed="50">50x</button>
            <button class="btn bg-white/10" data-speed="100">100x</button>
          </div>
        </div>
        <div class="glass rounded-xl px-3 py-2 text-xs flex items-center gap-2">
          <span>🎯 Davranış:</span>
          <button id="stanceBtn" class="btn bg-emerald-500/15">Agresif</button>
        </div>
        <button id="newGame" class="btn bg-emerald-500/20 border-emerald-400/30">↻ Yeni Oyun</button>
        <button id="helpBtn" class="btn bg-sky-500/20 border-sky-400/30">❔ Yardım</button>
        <button id="runTests" class="btn bg-white/10">🧪 Test</button>
      </div>
    </div>
  </header>

  <!-- MAP -->
  <main class="relative">
    <div id="map"></div>

    <!-- LEFT ACTION BAR -->
    <div class="glass rounded-2xl p-3 absolute left-3 top-3 z-[5000] w-[260px]">
      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">İnşa Et</div>
      <div class="grid grid-cols-2 gap-2 mb-3">
        <button class="btn bg-white/5 hover:bg-white/10" data-build="mill">🌾 Değirmen <span class="opacity-70 text-xs">(💰100)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="refinery">🛢️ Rafineri <span class="opacity-70 text-xs">(💰50)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="port">⚓ Liman <span class="opacity-70 text-xs">(💰200)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="barracks">🎖️ Kışla <span class="opacity-70 text-xs">(💰100)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10 col-span-2" data-build="factory">🏭 Tank Fabrikası <span class="opacity-70 text-xs">(💰150 + 🛢️50)</span></button>
      </div>
      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Üret</div>
      <div class="grid grid-cols-2 gap-2">
        <button id="spawnSoldier" class="btn bg-white/5 hover:bg-white/10">🪖 Asker <span class="opacity-70 text-xs">(💰30)</span></button>
        <button id="spawnTank" class="btn bg-white/5 hover:bg-white/10">🛡️ Tank <span class="opacity-70 text-xs">(💰80 + 🛢️40)</span></button>
        <button id="spawnExcavator" class="btn bg-white/5 hover:bg-white/10 col-span-2">⛏️ Kepçe <span class="opacity-70 text-xs">(💰70 + 🛢️20)</span></button>
      </div>
      <div class="mt-3 text-xs opacity-70">İpucu: İnşa etmek için tipi seç ve haritada konum tıkla. Kepçe gidip kurar. Seçili birimleri haritada boş alana tıklayarak yönlendir. "Davranış: Tut" modunda asker/tanklar hedef kovalamaz.</div>
    </div>

    <!-- RIGHT PANEL: QUEUE & LOG -->
    <div class="glass rounded-2xl p-3 absolute right-3 top-3 z-[5000] w-[300px]">
      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Kepçe Görev Kuyruğu</div>
      <ul id="queue" class="space-y-1 text-sm"></ul>
      <div class="mt-3 text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Savaş Günlüğü</div>
      <div id="log" class="text-xs max-h-48 overflow-auto leading-relaxed pr-1"></div>
    </div>

    <!-- BOTTOM HINT BAR -->
    <div id="hint" class="glass rounded-xl px-3 py-2 text-sm absolute left-1/2 -translate-x-1/2 bottom-4 z-[5000]">Hazır.</div>
  </main>

  <!-- FOOTER -->
  <footer class="glass w-full text-center text-xs py-2 opacity-70">Made with ❤️ on Leaflet • Demo oyun mekaniği (tek dosya)</footer>
</div>

<!-- HELP MODAL -->
<div id="helpModal" class="modal">
  <div class="glass rounded-2xl p-6 max-w-xl text-sm">
    <div class="text-lg font-bold mb-2">Nasıl Oynanır?</div>
    <ul class="list-disc pl-5 space-y-2">
      <li>Oyun başladığında <b>aynı şehirde</b>, birbirine <b>yakın</b> iki üs (siz ve AI) kurulur. Her ikisinin yanında birer <b>Kepçe</b> vardır.</li>
      <li><b>İnşa</b> bölümünden bir yapı seçin ve haritada konum tıklayın. Kepçe oraya gider ve inşa eder (Fabrika: <b>60sn</b>, diğerleri: <b>30sn</b>).</li>
      <li><b>Değirmen</b> para, <b>Rafineri</b> petrol üretir. <b>Liman</b> tüm para üretimini %20 artırır.</li>
      <li><b>Kışla</b> asker, <b>Fabrika</b> tank üretmek için gerekir. Üretim butonları sağda. <b>Kepçe</b>yi artık üsten de satın alabilirsiniz.</li>
      <li>Birimi seçmek için üzerine tıklayın (Shift ile çoklu seçim). Haritada boş alana tıklayın: hareket eder. Düşmana tıklarsanız saldırır.</li>
      <li>Davranış düğmesi ile <b>Agresif</b> (hedef kovalar) / <b>Tut</b> (sadece menzile girerse ateş eder, kovalamaz) modunu seçin.</li>
      <li>Üstteki hız kaydırıcısı ile oyunu <b>100x</b>'e kadar hızlandırın.</li>
      <li>Üs yok edilirse oyun biter.</li>
    </ul>
    <div class="mt-4 text-right"><button class="btn bg-white/10" onclick="document.getElementById('helpModal').classList.remove('show')">Kapat</button></div>
  </div>
</div>

<script>
(()=>{
  // --- WORLD RTS (Single-file) ---
  // Lightweight RTS core built on Leaflet. No external game engine.

  /* -------------------------- Map Setup -------------------------- */
  const map = L.map('map', { zoomControl:true, worldCopyJump:true, minZoom:2, maxZoom:18 });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap',
    noWrap:false
  }).addTo(map);

  // SVG overlay for attack beams
  const svgLayer = L.svg({ clickable:false }).addTo(map);
  const svg = (function ensureSVG(){
    let el = svgLayer._container;
    if(!el || el.tagName?.toLowerCase() !== 'svg'){
      el = svgLayer._container?.querySelector?.('svg') || document.createElementNS('http://www.w3.org/2000/svg','svg');
      (svgLayer._container || map.getPanes().overlayPane).appendChild(el);
    }
    return el;
  })();

  /* -------------------------- UI Refs -------------------------- */
  const moneyEl = document.getElementById('money');
  const oilEl = document.getElementById('oil');
  const excEl = document.getElementById('excCount');
  const soldierEl = document.getElementById('soldierCount');
  const tankEl = document.getElementById('tankCount');
  const hintEl = document.getElementById('hint');
  const queueEl = document.getElementById('queue');
  const logEl = document.getElementById('log');
  const helpBtn = document.getElementById('helpBtn');
  helpBtn.onclick = ()=> document.getElementById('helpModal').classList.add('show');
  document.getElementById('newGame').onclick = ()=>{ location.reload() };
  document.getElementById('runTests').onclick = ()=> runSelfTests();

  const speedRange = document.getElementById('speedRange');
  const speedLbl = document.getElementById('speedLbl');
  document.querySelectorAll('[data-speed]').forEach(b=> b.addEventListener('click',()=> setSpeed(+b.dataset.speed)));
  speedRange.addEventListener('input', ()=> setSpeed(+speedRange.value));

  const stanceBtn = document.getElementById('stanceBtn');
  stanceBtn.addEventListener('click', ()=>{
    playerStance = (playerStance==='aggressive')? 'hold' : 'aggressive';
    stanceBtn.textContent = playerStance==='aggressive'? 'Agresif' : 'Tut';
    stanceBtn.className = 'btn ' + (playerStance==='aggressive'? 'bg-emerald-500/15' : 'bg-yellow-500/20');
  });

  function setSpeed(v){ gameSpeed = Math.max(1, Math.min(100, v)); speedRange.value = String(gameSpeed); speedLbl.textContent = gameSpeed+'x'; hint('Hız: '+gameSpeed+'x'); }

  function hint(msg){ hintEl.textContent = msg }
  function log(msg){ const t = document.createElement('div'); t.textContent = msg; logEl.prepend(t); }

  /* -------------------------- Game Data -------------------------- */
  const LAND_SEEDS = [
    [41.0082,28.9784], // Istanbul
    [39.9208,32.8541], // Ankara
    [48.8566,2.3522],  // Paris
    [52.52,13.405],    // Berlin
    [40.7128,-74.0060],// NYC
    [34.0522,-118.2437], // LA
    [35.6762,139.6503], // Tokyo
    [19.4326,-99.1332], // Mexico City
    [31.2304,121.4737], // Shanghai
    [28.6139,77.2090], // Delhi
    [30.0444,31.2357], // Cairo
    [6.5244,3.3792],   // Lagos
    [-33.8688,151.2093], // Sydney
    [37.7749,-122.4194], // SF
    [-23.5505,-46.6333], // Sao Paulo
    [41.9028,12.4964], // Rome
    [50.1109,8.6821],  // Frankfurt
    [59.3293,18.0686], // Stockholm
    [1.3521,103.8198], // Singapore
    [35.6892,51.3890], // Tehran
    [41.015, 29.2],    // East of Istanbul
    [38.4237,27.1428], // Izmir
  ];

  const START = { CITY_ZOOM: 10, PLAYER_RADIUS: 800, AI_RADIUS: 1100, SEPARATION_DEG: Math.PI }; // ~1km civarı

  const COST = {
    mill:      { money:100, oil:0, build:30 },
    refinery:  { money:50,  oil:0, build:30 },
    port:      { money:200, oil:0, build:30 },
    factory:   { money:150, oil:50, build:60 }, // 60s specifically
    barracks:  { money:100, oil:0, build:30 },
    tank:      { money:80,  oil:40 },
    soldier:   { money:30,  oil:0 },
    excavator: { money:70,  oil:20 }, // yeni: üsten kepçe satın alma maliyeti
  };

  const STATS = {
    kepce:   { hp:120, speed:18, range:0,   dps:0 },
    soldier: { hp:60,  speed:22, range:45,  dps:10 },
    tank:    { hp:200, speed:16, range:80,  dps:25 },
    base:    { hp:800 },
    mill:    { hp:220 },
    refinery:{ hp:240 },
    port:    { hp:260 },
    factory: { hp:340 },
    barracks:{ hp:280 },
  };

  const RATES = {
    moneyPerMill: 3,       // per tick
    oilPerRef: 2,
    tickSec: 3,            // income tick
    portBonus: 0.20,       // +20% money from all mills
  }

  const LAYERS = { units:L.layerGroup().addTo(map), buildings:L.layerGroup().addTo(map) };

  function randInt(n){ return Math.floor(Math.random()*n) }
  function choose(arr){ return arr[randInt(arr.length)] }

  function distance(a,b){ return map.distance(a,b) }

  function latlngTowards(from, to, distMeters){
    const total = distance(from,to);
    if(total===0 || distMeters>=total) return to;
    const r = distMeters/total;
    const lat = from.lat + (to.lat - from.lat)*r;
    const lng = from.lng + (to.lng - from.lng)*r;
    return L.latLng(lat,lng);
  }

  function offsetDir(latlng, meters, angleRad){
    const d=meters, ang=angleRad;
    const lat = latlng.lat + (d*Math.cos(ang))/111320;
    const lng = latlng.lng + (d*Math.sin(ang))/(40075000*Math.cos(latlng.lat*Math.PI/180)/360);
    return L.latLng(lat,lng);
  }

  function offset(latlng, meters){
    return offsetDir(latlng, meters, Math.random()*Math.PI*2);
  }

  /* -------------------------- Entities -------------------------- */
  let ENT_ID=1;
  const Side = { PLAYER:'player', AI:'ai' };

  class Entity{
    constructor(opts){ Object.assign(this, opts); this.id = ENT_ID++; this.dead=false }
  }

  class Unit extends Entity{
    constructor(opts){
      super(opts);
      this.hp = STATS[this.unitType].hp;
      this.speed = STATS[this.unitType].speed; // m/s
      this.range = STATS[this.unitType].range||0; // m
      this.dps = STATS[this.unitType].dps||0; // per sec
      this.dest = null; this.target=null; this.moveVec=null;
      this.marker = createMarker(this, true);
    }
  }

  class Building extends Entity{
    constructor(opts){
      super(opts);
      this.hp = STATS[this.buildingType].hp;
      this.marker = createMarker(this, false);
    }
  }

  const player = { money:120, oil:50, units:[], buildings:[], base:null, ports:()=>player.buildings.filter(b=>b.buildingType==='port').length };
  const ai     = { money:120, oil:50, units:[], buildings:[], base:null, lastThink:0 };

  const selection = new Set();
  let buildMode=null; // selected building type
  let playerStance = 'aggressive'; // 'aggressive' | 'hold'

  function updateHUD(){
    moneyEl.textContent = Math.floor(player.money);
    oilEl.textContent = Math.floor(player.oil);
    excEl.textContent = player.units.filter(u=>u.unitType==='kepce').length;
    soldierEl.textContent = player.units.filter(u=>u.unitType==='soldier').length;
    tankEl.textContent = player.units.filter(u=>u.unitType==='tank').length;
  }

  function createMarker(ent, isUnit){
    const isPlayer = ent.side===Side.PLAYER;
    const html = `<div class="${isUnit?'unit':'building'} ${isPlayer?'player':'ai'} ${cssClass(ent)}">
      <div class="hpbar"><div class="hpfill" style="width:100%"></div></div>
    </div>`;
    const icon = L.divIcon({ className:'', html, iconSize:[ isUnit?22:28, isUnit?22:28 ] });
    const marker = L.marker(ent.pos, { icon, zIndexOffset:isUnit? 1000 : 500 }).addTo(isUnit? LAYERS.units : LAYERS.buildings);
    marker.on('click', (e)=> onMarkerClick(ent, e));
    marker.on('contextmenu', (e)=> onMarkerRightClick(ent, e));
    return marker;
  }

  function cssClass(ent){
    if(ent.unitType){
      if(ent.unitType==='kepce') return 'kepce';
      if(ent.unitType==='soldier') return 'soldier';
      if(ent.unitType==='tank') return 'tank';
    } else if(ent.buildingType){
      if(ent.isBase) return 'base';
      return ent.buildingType;
    }
    return 'neutral'
  }

  function setSelected(ent, val){
    const el = ent.marker.getElement()?.firstChild; // div.unit/building
    if(!el) return;
    if(val) { el.classList.add('sel'); selection.add(ent) }
    else { el.classList.remove('sel'); selection.delete(ent) }
  }

  function clearSelection(){ [...selection].forEach(ent=> setSelected(ent,false)) }

  function onMarkerClick(ent, e){
    if(e.originalEvent.shiftKey){ setSelected(ent, !selection.has(ent)); }
    else { clearSelection(); setSelected(ent, true); }
  }

  function onMarkerRightClick(ent, e){ /* future: context menu */ }

  map.on('click', (e)=>{
    if(buildMode){
      const type = buildMode; buildMode=null; hint('Kepçe inşa için yola çıktı.');
      const job = { type, pos:e.latlng };
      enqueueBuildJob(player, job);
    } else if(selection.size>0){
      selection.forEach(ent=>{
        if(ent instanceof Unit){ ent.dest = e.latlng; ent.target=null; }
      });
      hint('Hareket emri verildi.');
    }
  });

  map.on('contextmenu', (e)=>{ clearSelection(); hint('Seçim temizlendi.'); });

  function enqueueBuildJob(sideObj, job){
    const kepces = sideObj.units.filter(u=>u.unitType==='kepce');
    const free = kepces.find(k=>!k.job);
    if(free){ free.job = job; free.dest = job.pos; updateQueueUI(); }
    else { (sideObj.queue ||= []).push(job); updateQueueUI(); }
  }

  function updateQueueUI(){
    queueEl.innerHTML = '';
    const list = (player.units.filter(u=>u.unitType==='kepce').map(k=> k.job? `⛏️ ${labelOf(k.job.type)} kuruluyor` : '⏳ Boş') ).concat( (player.queue||[]).map(j=>`🧱 Sırada: ${labelOf(j.type)}`) );
    list.forEach(t=>{ const li=document.createElement('li'); li.textContent=t; queueEl.appendChild(li) });
  }

  function labelOf(type){
    const m={mill:'Değirmen', refinery:'Rafineri', port:'Liman', factory:'Tank Fabrikası', barracks:'Kışla'}; return m[type]||type
  }

  /* -------------------------- Income -------------------------- */
  let incomeTimer=0;
  function incomeTick(dt){
    incomeTimer += dt; if(incomeTimer < RATES.tickSec) return; incomeTimer=0;
    const mills = player.buildings.filter(b=>b.buildingType==='mill').length;
    const refs  = player.buildings.filter(b=>b.buildingType==='refinery').length;
    const ports = player.ports();
    let moneyAdd = mills * RATES.moneyPerMill * (1 + ports*RATES.portBonus);
    let oilAdd = refs * RATES.oilPerRef;
    player.money += moneyAdd; player.oil += oilAdd;

    const amills = ai.buildings.filter(b=>b.buildingType==='mill').length;
    const arefs  = ai.buildings.filter(b=>b.buildingType==='refinery').length;
    const aports = ai.buildings.filter(b=>b.buildingType==='port').length;
    let amoneyAdd = amills * RATES.moneyPerMill * (1 + aports*RATES.portBonus);
    let aoilAdd = arefs * RATES.oilPerRef;
    ai.money += amoneyAdd; ai.oil += aoilAdd;

    updateHUD();
  }

  /* -------------------------- Combat -------------------------- */
  function inRange(u, v){ return distance(u.pos, v.pos) <= (u.range||0) }

  function dealDamage(attacker, target, dt){
    if(attacker.dps<=0) return;
    target.hp -= attacker.dps * dt;
    updateHPBar(target);
    if(target.hp <= 0) destroyEntity(target, attacker);
    if(Math.random()<.3) drawBeam(attacker.pos, target.pos);
  }

  function updateHPBar(ent){
    const el = ent.marker.getElement(); if(!el) return; const fill = el.querySelector('.hpfill');
    const maxHP = ent.unitType? STATS[ent.unitType].hp : STATS[ent.buildingType].hp;
    const pct = Math.max(0, Math.min(100, (ent.hp/maxHP)*100));
    fill.style.width = pct+'%';
    fill.style.background = pct<33? 'linear-gradient(90deg,#ef4444,#dc2626)': pct<66? 'linear-gradient(90deg,#f59e0b,#d97706)': 'linear-gradient(90deg,#22c55e,#16a34a)';
  }

  function drawBeam(a,b){
    if(!svg) return;
    const p1 = map.latLngToLayerPoint(a), p2 = map.latLngToLayerPoint(b);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',p1.x); line.setAttribute('y1',p1.y); line.setAttribute('x2',p2.x); line.setAttribute('y2',p2.y);
    line.setAttribute('class','beam');
    svg.appendChild(line);
    setTimeout(()=> line.remove(), 160);
  }

  function destroyEntity(ent, killer){
    ent.dead = true;
    if(ent.marker){ ent.marker.remove(); }
    if(ent.unitType){
      const arr = ent.side===Side.PLAYER? player.units : ai.units; const i = arr.indexOf(ent); if(i>=0) arr.splice(i,1);
    } else {
      const arr = ent.side===Side.PLAYER? player.buildings : ai.buildings; const i = arr.indexOf(ent); if(i>=0) arr.splice(i,1);
      if(ent.isBase){
        if(ent.side===Side.PLAYER) endGame(false); else endGame(true);
      }
    }
    if(selection.has(ent)) selection.delete(ent);
    if(killer) log(`${killer.side==='player'?'Bizim':'AI'} ${killer.unitType||killer.buildingType} birimi ${ent.unitType||ent.buildingType} yok etti.`);
    updateHUD();
  }

  function endGame(win){
    const modal = document.getElementById('helpModal');
    const box = modal.querySelector('.glass');
    modal.classList.add('show');
    box.querySelector('.text-lg').textContent = win? 'Zafer!' : 'Yenilgi!';
    box.querySelector('ul').innerHTML = `<li>${win? 'AI üssünü yok ettiniz. Harika komutanlık!' : 'Üssünüz yok edildi. Tekrar deneyin!'}</li>`;
  }

  /* -------------------------- Game Init -------------------------- */
  function initGame(){
    // Aynı şehirde ve yakın konumda başlat
    const city = choose(LAND_SEEDS);
    const center = L.latLng(city[0], city[1]);
    const angle = Math.random() * Math.PI * 2;

    const pPos = offsetDir(center, START.PLAYER_RADIUS, angle);
    const aPos = offsetDir(center, START.AI_RADIUS, angle + START.SEPARATION_DEG); // karşı yönde ~1.1km

    const pBase = new Building({ side:Side.PLAYER, pos:pPos, buildingType:'base', isBase:true });
    const aBase = new Building({ side:Side.AI,     pos:aPos, buildingType:'base', isBase:true });
    player.base = pBase; ai.base = aBase; player.buildings.push(pBase); ai.buildings.push(aBase);

    const pKep = new Unit({ side:Side.PLAYER, pos:offset(pBase.pos, 120), unitType:'kepce' }); player.units.push(pKep);
    const aKep = new Unit({ side:Side.AI,     pos:offset(aBase.pos, 120), unitType:'kepce' }); ai.units.push(aKep);

    map.setView(center, START.CITY_ZOOM);
    updateHUD();
    updateQueueUI();
    hint('Aynı şehirde, yakın başlangıç! İlk yapınızı inşa edin.');

    aiThink(0,true);
  }

  /* -------------------------- Build & Train -------------------------- */
  const buildBtns = document.querySelectorAll('[data-build]');
  buildBtns.forEach(btn=> btn.addEventListener('click',()=>{
    const type = btn.dataset.build;
    if(player.money < (COST[type].money||0) || player.oil < (COST[type].oil||0)) { hint('Yetersiz kaynak.'); return; }
    player.money -= (COST[type].money||0); player.oil -= (COST[type].oil||0); updateHUD();
    buildMode = type; hint(`${labelOf(type)} için konum seçin.`);
  }));

  document.getElementById('spawnSoldier').onclick = ()=>{
    if(!player.buildings.some(b=>b.buildingType==='barracks')){ hint('Önce Kışla kurun.'); return }
    if(player.money < COST.soldier.money){ hint('Yetersiz para.'); return }
    player.money -= COST.soldier.money; updateHUD();
    spawnUnitNear('soldier', player);
  }
  document.getElementById('spawnTank').onclick = ()=>{
    if(!player.buildings.some(b=>b.buildingType==='factory')){ hint('Önce Tank Fabrikası kurun.'); return }
    if(player.money < COST.tank.money || player.oil < COST.tank.oil){ hint('Yetersiz kaynak.'); return }
    player.money -= COST.tank.money; player.oil -= COST.tank.oil; updateHUD();
    spawnUnitNear('tank', player);
  }
  document.getElementById('spawnExcavator').onclick = ()=>{
    if(player.money < COST.excavator.money || player.oil < COST.excavator.oil){ hint('Kepçe için kaynak yetersiz.'); return }
    player.money -= COST.excavator.money; player.oil -= COST.excavator.oil; updateHUD();
    spawnUnitNear('kepce', player);
  }

  function spawnUnitNear(kind, sideObj){
    const around = sideObj.base.pos; const pos = offset(around, randInt(120)+50);
    const u = new Unit({ side: sideObj===player? Side.PLAYER:Side.AI, pos, unitType:kind });
    (sideObj.units).push(u); updateHUD();
  }

  /* -------------------------- Kepçe Build Flow -------------------------- */
  function tickKepce(dt, u, owner){
    moveUnit(dt, u);
    if(u.job && u.dest==null){
      if(!u.buildTask){
        const type = u.job.type;
        const b = new Building({ side:u.side, pos:u.job.pos, buildingType:type });
        b.buildProgress = 0; b.buildNeeded = COST[type].build; 
        b.underConstruction = true;
        b.marker.getElement().querySelector('.hpbar').insertAdjacentHTML('beforebegin','<div class="buildbar"><div class="buildfill" style="width:0%"></div></div>');
        u.buildTask = b; 
        (owner.buildings).push(b);
      } else {
        u.buildTask.buildProgress += dt;
        const pct = Math.min(100, (u.buildTask.buildProgress/u.buildTask.buildNeeded)*100);
        const el = u.buildTask.marker.getElement(); if(el){ const f = el.querySelector('.buildfill'); if(f) f.style.width=pct+'%'; }
        if(u.buildTask.buildProgress>=u.buildTask.buildNeeded){
          u.buildTask.underConstruction=false;
          const el2 = u.buildTask.marker.getElement(); if(el2){ const bb = el2.querySelector('.buildbar'); if(bb) bb.remove(); }
          log(`${owner===player?'Bizim':'AI'} ${labelOf(u.job.type)} tamamlandı.`);
          u.job = null; u.buildTask=null;
          if(owner.queue && owner.queue.length>0){ u.job = owner.queue.shift(); u.dest = u.job.pos; }
          updateQueueUI(); updateHUD();
        }
      }
    }
  }

  function moveUnit(dt, u){
    if(!u.dest) return;
    const step = u.speed * dt; 
    const next = latlngTowards(u.pos, u.dest, step);
    u.pos = next; u.marker.setLatLng(u.pos);
    if(distance(u.pos, u.dest) < 4){ u.dest=null }
  }

  /* -------------------------- Combat & AI Targeting -------------------------- */
  function tickCombat(dt, sideObj, enemySide){
    const units = sideObj.units;
    const enemies = enemySide.units.concat(enemySide.buildings);

    for(const u of units){
      moveUnit(dt, u);
      if(u.dps>0){
        if(sideObj===player && playerStance==='hold'){
          // HOLD: ateş eder ama kovalamaz
          if(u.target && inRange(u, u.target)) dealDamage(u, u.target, dt);
          else {
            const immediate = acquireTargetInRange(u, enemies);
            if(immediate) { u.target = immediate; dealDamage(u, u.target, dt); }
          }
          continue; // default agresifi atla
        }

        // AGGRESSIVE (varsayılan) + AI
        if(!u.target || u.target.dead){ u.target = acquireTarget(u, enemies); }
        else if(distance(u.pos, u.target.pos) > (u.range*1.1)){ u.dest = u.target.pos; }
        if(u.target && inRange(u, u.target)){
          dealDamage(u, u.target, dt);
        }
      }
    }
  }

  function acquireTarget(u, enemies){
    let best=null, bestD=Infinity;
    for(const e of enemies){ if(e.dead) continue; const d=distance(u.pos,e.pos); if(d<bestD){ best=e; bestD=d; } }
    return best;
  }
  function acquireTargetInRange(u, enemies){
    let best=null, bestD=Infinity; const R=u.range||0;
    for(const e of enemies){ if(e.dead) continue; const d=distance(u.pos,e.pos); if(d<=R && d<bestD){ best=e; bestD=d; } }
    return best;
  }

  /* -------------------------- AI -------------------------- */
  function aiThink(dt, forceSeed=false){
    ai.lastThink += dt;
    if(forceSeed || ai.lastThink>5){
      ai.lastThink=0;
      const hasMill = ai.buildings.some(b=>b.buildingType==='mill');
      const hasRef  = ai.buildings.some(b=>b.buildingType==='refinery');
      const hasBarr = ai.buildings.some(b=>b.buildingType==='barracks');
      const hasFac  = ai.buildings.some(b=>b.buildingType==='factory');

      if(!hasMill && ai.money>=COST.mill.money) { ai.money-=COST.mill.money; enqueueBuildJob(ai, {type:'mill', pos: offset(ai.base.pos, 800) }); }
      else if(!hasRef && ai.money>=COST.refinery.money) { ai.money-=COST.refinery.money; enqueueBuildJob(ai, {type:'refinery', pos: offset(ai.base.pos, 1000) }); }
      else if(!hasBarr && ai.money>=COST.barracks.money) { ai.money-=COST.barracks.money; enqueueBuildJob(ai, {type:'barracks', pos: offset(ai.base.pos, 600) }); }
      else if(!hasFac && ai.money>=COST.factory.money && ai.oil>=COST.factory.oil) { ai.money-=COST.factory.money; ai.oil-=COST.factory.oil; enqueueBuildJob(ai, {type:'factory', pos: offset(ai.base.pos, 1200) }); }

      if(hasBarr && ai.money>=COST.soldier.money && Math.random()<.7) { ai.money-=COST.soldier.money; spawnUnitNear('soldier', ai); }
      if(hasFac && ai.money>=COST.tank.money && ai.oil>=COST.tank.oil && Math.random()<.5) { ai.money-=COST.tank.money; ai.oil-=COST.tank.oil; spawnUnitNear('tank', ai); }

      const tanks = ai.units.filter(u=>u.unitType==='tank').length;
      const soldiers = ai.units.filter(u=>u.unitType==='soldier').length;
      if( (tanks>=2 || soldiers>=6) && Math.random()<.6 ){
        const target = acquireTarget({pos:ai.base.pos}, player.units.concat(player.buildings));
        if(target){ ai.units.forEach(u=>{ if(u.dps>0){ u.dest = target.pos; u.target=target; } }); log('AI saldırı başlattı!'); }
      }
    }
  }

  /* -------------------------- Game Loop with Speed -------------------------- */
  let last = performance.now();
  let gameSpeed = 1; setSpeed(1);
  const FIXED_STEP = 0.02; // 50 sim steps per second
  const MAX_STEPS = 300;   // güvenlik limiti (100x hızda da yeterli)
  let accumulator = 0;

  function step(dt){
    // kepçe logic
    player.units.filter(u=>u.unitType==='kepce').forEach(u=> tickKepce(dt, u, player));
    ai.units.filter(u=>u.unitType==='kepce').forEach(u=> tickKepce(dt, u, ai));

    // movement + combat
    tickCombat(dt, player, ai);
    tickCombat(dt, ai, player);

    // economy + ai
    incomeTick(dt);
    aiThink(dt);
  }

  function loop(now){
    const baseDt = Math.min(0.1, (now-last)/1000); // tab değişince dev adımları kıs
    last = now;
    accumulator += baseDt * gameSpeed;

    let steps=0;
    while(accumulator >= FIXED_STEP && steps < MAX_STEPS){
      step(FIXED_STEP);
      accumulator -= FIXED_STEP;
      steps++;
    }

    requestAnimationFrame(loop);
  }

  /* -------------------------- Self Tests (runtime) -------------------------- */
  function runSelfTests(){
    try {
      console.assert(svg instanceof SVGSVGElement, 'SVG container is ready');
      drawBeam(map.getCenter(), map.getCenter());
      log('🧪 Test: SVG/beam oluşturma ✅');
    } catch(e){
      log('🧪 Test: SVG/beam oluşturma ❌ ' + e.message);
      console.error(e);
    }
    try {
      const prev = gameSpeed; setSpeed(10); // 10x
      console.assert(gameSpeed===10, 'Speed set to 10');
      setSpeed(prev);
      log('🧪 Test: Hız kontrol ✅');
    } catch(e){ log('🧪 Test: Hız kontrol ❌ ' + e.message); console.error(e); }
    try {
      const c0 = player.units.filter(u=>u.unitType==='kepce').length; const m0=player.money, o0=player.oil;
      if(m0>=COST.excavator.money && o0>=COST.excavator.oil){
        spawnUnitNear('kepce', player);
        const c1 = player.units.filter(u=>u.unitType==='kepce').length;
        console.assert(c1===c0+1, 'Kepçe spawn artmalı');
        log('🧪 Test: Kepçe üretim ✅');
      } else {
        log('🧪 Test: Kepçe üretim atlandı (kaynak yetersiz)');
      }
    } catch(e){ log('🧪 Test: Kepçe üretim ❌ ' + e.message); console.error(e); }
    try {
      const d = distance(player.base.pos, ai.base.pos);
      console.assert(d < 3000, 'Üsler aynı şehir içinde yakın olmalı (<3km)');
      log('🧪 Test: Yakın başlangıç ✅ ('+Math.round(d)+'m)');
    } catch(e){ log('🧪 Test: Yakın başlangıç ❌ ' + e.message); console.error(e); }
  }

  /* -------------------------- Start -------------------------- */
  initGame();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
