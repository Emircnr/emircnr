<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>GLOBAL RTS — Tek Dosya Prototip</title>
  <!--\n  KURULUM NOTU
  - Firebase Realtime Database ve Anonymous Auth etkin olmalı.
  - Bu dosyayı kendi domaininizde çalıştırıyorsanız, Firebase Console > Authentication & Database alanlarında domaininize izin verin.
  - İki farklı tarayıcı/pencere ile bağlanıp aynı Oda ID'sine girerek PvP deneyin.
  -->

  <!-- Google Font: Montserrat -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
  <!-- TailwindCSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <style>
    :root{
      --bg:#0b1220; --panel:#111A2B; --text:#E6EDF6; --muted:#9AA4B2; --accent:#34d399;
      --glass: rgba(17,26,43,0.6);
      --beamA:#ff9100; --beamB:#ffd08a;
      --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --blue:#60a5fa;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: 'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, Arial}
    .glass{ background: var(--glass); backdrop-filter: blur(8px); box-shadow: 0 10px 30px rgba(0,0,0,.25); border: 1px solid rgba(255,255,255,0.06)}
    .btn{ @apply px-4 py-2 rounded-xl font-semibold transition active:scale-[.98]; background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.08)}
    .btn:hover{ filter: brightness(1.05)}
    .btn-accent{ background: linear-gradient(180deg, rgba(52,211,153,.25), rgba(52,211,153,.12)); border-color: rgba(52,211,153,.35)}
    .btn-red{ background: linear-gradient(180deg, rgba(239,68,68,.25), rgba(239,68,68,.12)); border-color: rgba(239,68,68,.35)}
    .tag{ @apply text-xs px-2 py-1 rounded-full; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1)}
    #map{ height: 100%; width: 100%}
    .hud-counter{ @apply flex items-center gap-1 px-2 py-1 rounded-lg; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08)}
    .panel{ @apply glass rounded-2xl p-3}
    .scroll-thin{ scrollbar-width: thin}

    /* Unit/Building icons via L.divIcon */
    .entity{ position: relative; width:22px; height:22px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.9), rgba(255,255,255,.15));
      border:1px solid rgba(255,255,255,.35); box-shadow:0 2px 8px rgba(0,0,0,.4)}
    .entity.p1{ outline:2px solid rgba(96,165,250,.7)}
    .entity.p2{ outline:2px solid rgba(244,114,182,.7)}
    .entity .emoji{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:14px}
    .entity.selected{ box-shadow:0 0 0 3px rgba(96,165,250,.5), 0 0 16px rgba(96,165,250,.35)}

    .marker-hq{ width:28px; height:28px; border-radius:12px; background: linear-gradient(180deg, rgba(34,197,94,.35), rgba(34,197,94,.05)); border:1px solid rgba(34,197,94,.6)}
    .marker-wall{ width:10px; height:10px; border-radius:2px; background:#60a5fa; border:1px solid rgba(255,255,255,.3)}

    /* Selection rectangle */
    .select-rect{ position:absolute; border:1px dashed #7dd3fc; background: rgba(125,211,252,.12); pointer-events:none; z-index:9999 }

    /* Beam glow */
    .leaflet-overlay-pane svg .beam{ stroke-linecap: round; filter: drop-shadow(0 0 4px rgba(255,145,0,.9))}

    /* Modal */
    .modal{ position: fixed; inset:0; background: rgba(0,0,0,.5); display:none; align-items:center; justify-content:center }
    .modal.show{ display:flex }

    /* Mobile controls */
    @media (max-width: 1024px){
      .mobile-row{ @apply fixed bottom-2 left-2 right-2 flex gap-2 justify-center z-50 }
    }
  </style>
</head>
<body class="min-h-screen">
  <!-- VIEWS WRAPPER -->
  <div id="app" class="grid grid-rows-[auto_1fr] h-screen">
    <!-- Top Bar (only in game) -->
    <div id="topbar" class="hidden glass sticky top-0 z-40">
      <div class="max-w-[1400px] mx-auto px-3 py-2 flex items-center gap-3">
        <div class="text-lg font-extrabold tracking-wide">GLOBAL RTS</div>
        <div class="flex items-center gap-2 flex-wrap">
          <div class="hud-counter" title="Para">💰 <span id="r-money">0</span></div>
          <div class="hud-counter" title="Petrol">🛢️ <span id="r-oil">0</span></div>
          <div class="hud-counter" title="Demir">⛓️ <span id="r-iron">0</span></div>
          <div class="hud-counter" title="Altın">🪙 <span id="r-gold">0</span></div>
          <div class="hud-counter" title="Tahıl">🌾 <span id="r-grain">0</span></div>
          <div class="hud-counter" title="Nüfus">👥 <span id="r-pop">0</span>/<span id="r-popcap">0</span></div>
        </div>
        <div class="ml-auto flex items-center gap-2">
          <span class="text-sm text-[var(--muted)]">Görsel Hız</span>
          <button class="btn tag" id="speed1">1x</button>
          <button class="btn tag" id="speed5">5x</button>
          <button class="btn tag" id="speed10">10x</button>
          <button class="btn" id="helpBtn">Yardım</button>
          <button class="btn btn-red" id="leaveBtn">Ayrıl</button>
        </div>
      </div>
    </div>

    <!-- MAIN AREA: Views -->
    <div class="relative">
      <!-- View A: Auth / Landing -->
      <section data-view="auth" id="view-auth" class="h-full flex items-center justify-center p-6">
        <div class="glass rounded-3xl max-w-xl w-full p-8">
          <div class="text-3xl font-extrabold mb-2">GLOBAL RTS</div>
          <p class="text-[var(--muted)] mb-6">Tarayıcı tabanlı PvP mikro-RTS prototipi. Anonim giriş yapın, oda kurun veya ID ile katılın.</p>
          <div class="flex flex-col gap-3">
            <label class="text-sm">Takma Ad</label>
            <input id="nickInput" class="w-full glass rounded-xl px-4 py-3 outline-none" placeholder="Örn: Komutan_42"/>
            <button id="anonLoginBtn" class="btn btn-accent text-lg mt-2">Anonim Giriş</button>
          </div>
        </div>
      </section>

      <!-- View B: Lobby -->
      <section data-view="lobby" id="view-lobby" class="hidden h-full p-6">
        <div class="max-w-[1100px] mx-auto grid lg:grid-cols-2 gap-6">
          <div class="panel">
            <div class="text-xl font-bold mb-2">Yeni Oda Kur</div>
            <p class="text-[var(--muted)] mb-3">Host siz olursunuz. Oyunu başlatma yetkisi sizde.</p>
            <button id="createRoomBtn" class="btn btn-accent">Oda Oluştur</button>
          </div>
          <div class="panel">
            <div class="text-xl font-bold mb-2">Odaya Katıl</div>
            <p class="text-[var(--muted)] mb-3">Arkadaşınızın verdiği 8 karakterlik oda ID'sini girin.</p>
            <div class="flex gap-2">
              <input id="joinRoomId" class="flex-1 glass rounded-xl px-4 py-2" placeholder="Örn: 7G9K1QXZ"/>
              <button id="joinRoomBtn" class="btn">Katıl</button>
            </div>
          </div>
          <div class="panel lg:col-span-2">
            <div class="font-semibold mb-2">Bilgi</div>
            <ul class="text-sm text-[var(--muted)] list-disc pl-5 space-y-1">
              <li>Lockstep ağ modeli: 10 Hz tik, 3 tik komut gecikmesi.</li>
              <li>Saldırı efekti: turuncu ışın çizgisi (gradient + glow).</li>
              <li>İpucu: Sağ tık hareket/atak, sürükle çoklu seçim. Mobil için alt kısayol tuşları.</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- View C: Room -->
      <section data-view="room" id="view-room" class="hidden h-full p-6">
        <div class="max-w-[1100px] mx-auto grid lg:grid-cols-3 gap-6">
          <div class="panel lg:col-span-2">
            <div class="flex items-center gap-3 mb-3">
              <div class="text-xl font-bold">Oda</div>
              <div id="roomIdBadge" class="tag"></div>
            </div>
            <div class="grid md:grid-cols-2 gap-3" id="playersBox"></div>
            <div class="mt-4 flex items-center gap-3">
              <label class="flex items-center gap-2"><input id="readyToggle" type="checkbox" class="scale-125"> <span>Hazırım</span></label>
              <button id="startBtn" class="btn btn-accent hidden">Başlat (Host)</button>
              <button id="backToLobby" class="btn">Lobiye Dön</button>
            </div>
          </div>
          <div class="panel">
            <div class="font-semibold mb-2">Kurallar</div>
            <p class="text-sm text-[var(--muted)]">İki oyuncu da hazır olduğunda host başlatır. Kazanmak için düşman HQ'yu yok et.</p>
            <div class="mt-3 text-sm text-[var(--muted)]">Presence gerçek zamanlı güncellenir.</div>
          </div>
        </div>
      </section>

      <!-- View D: Game -->
      <section data-view="game" id="view-game" class="hidden h-[calc(100vh-58px)] relative">
        <!-- Left panel -->
        <div class="absolute left-3 top-3 w-64 panel z-30">
          <div class="flex items-center justify-between mb-2">
            <div class="font-bold">İnşa / Üret</div>
            <button id="toggleBuild" class="tag">Aç/Kapa</button>
          </div>
          <div id="buildPanel" class="space-y-2 max-h-[40vh] overflow-auto scroll-thin">
            <!-- Dinamik butonlar -->
          </div>
          <div id="producePanel" class="mt-3 pt-3 border-t border-white/10 hidden">
            <div class="font-semibold mb-2">Üret (Seçili Bina)</div>
            <div id="produceButtons" class="space-y-2"></div>
          </div>
        </div>
        <!-- Right panel -->
        <div class="absolute right-3 top-3 w-72 panel z-30">
          <div class="font-bold mb-2">Kuyruk & Günlük</div>
          <div class="text-sm text-[var(--muted)] mb-1">İnşa/üretim kuyruğu:</div>
          <ul id="queueList" class="text-sm space-y-1 max-h-[20vh] overflow-auto scroll-thin"></ul>
          <div class="text-sm text-[var(--muted)] mt-3 mb-1">Savaş günlüğü:</div>
          <ul id="combatLog" class="text-sm space-y-1 max-h-[26vh] overflow-auto scroll-thin"></ul>
        </div>
        <!-- Hint bottom -->
        <div class="absolute left-1/2 -translate-x-1/2 bottom-2 z-30">
          <div id="hint" class="tag">Hazır</div>
        </div>

        <!-- Mobile controls -->
        <div class="mobile-row">
          <button id="mSelect" class="btn">Seç</button>
          <button id="mMove" class="btn">Hareket</button>
          <button id="mAttack" class="btn">Saldırı</button>
          <button id="mStop" class="btn">Durdur</button>
        </div>

        <!-- Map -->
        <div id="map" class="absolute inset-0"></div>

        <!-- Selection rectangle -->
        <div id="selectRect" class="select-rect hidden"></div>
      </section>

      <!-- Modals -->
      <div id="helpModal" class="modal">
        <div class="panel rounded-3xl w-[min(720px,92vw)] p-6">
          <div class="text-2xl font-extrabold mb-2">Yardım</div>
          <ul class="text-sm text-[var(--muted)] space-y-1 list-disc pl-5">
            <li><b>Sol tık</b>: Seç / sürükle çoklu seçim</li>
            <li><b>Sağ tık boş</b>: Hareket • <b>Sağ tık düşman</b>: Saldırı</li>
            <li><b>H</b>: Yardım • <b>1/5/0</b>: Görsel hız 1x/5x/10x</li>
            <li><b>K</b>: Seçili kapı kilit/aç</li>
            <li>Ekonomi her <b>3sn</b>'de bir gelir sağlar. Pazar bonusu %20 (maks %60).</li>
          </ul>
          <div class="mt-4 flex justify-end">
            <button id="helpClose" class="btn">Kapat</button>
          </div>
        </div>
      </div>

      <div id="resultModal" class="modal">
        <div class="panel rounded-3xl w-[min(520px,92vw)] p-6 text-center">
          <div id="resultTitle" class="text-3xl font-extrabold mb-2">Zafer</div>
          <div id="resultSub" class="text-[var(--muted)] mb-4">Düşman HQ yok edildi.</div>
          <button id="resultOk" class="btn btn-accent">Lobiye Dön</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ---------------------------
    // Firebase Setup (Inline)
    // ---------------------------
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
    import { getDatabase, ref, set, get, update, onValue, onChildAdded, onChildRemoved, onDisconnect, serverTimestamp, child } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js';

    const firebaseConfig = {
      apiKey: "AIzaSyCV609XeHMtmZtD3FZDJ0cQnDiXke4YlUs",
      authDomain: "globalrts-ea3b4.firebaseapp.com",
      databaseURL: "https://globalrts-ea3b4-default-rtdb.firebaseio.com",
      projectId: "globalrts-ea3b4",
      storageBucket: "globalrts-ea3b4.firebasestorage.app",
      messagingSenderId: "404807030737",
      appId: "1:404807030737:web:2efecfef884db0b58632f0",
      measurementId: "G-Q5YKGP8EXR"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    // ---------------------------
    // DOM Helpers + Views
    // ---------------------------
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    function setView(id){
      $$('[data-view]').forEach(v => v.classList.add('hidden'));
      const el = document.getElementById(`view-${id}`);
      if(el) el.classList.remove('hidden');
      // Topbar only in game
      document.getElementById('topbar').classList.toggle('hidden', id !== 'game');
    }

    const hintEl = document.getElementById('hint');
    function hint(msg){ hintEl.textContent = msg; hintEl.classList.add('animate-pulse'); setTimeout(()=>hintEl.classList.remove('animate-pulse'), 400); }

    // ---------------------------
    // Auth Flow
    // ---------------------------
    const anonLoginBtn = document.getElementById('anonLoginBtn');
    const nickInput = document.getElementById('nickInput');
    let me = { uid: null, nick: null };

    // Random nick default
    nickInput.value = `Komutan_${Math.floor(Math.random()*900+100)}`;

    anonLoginBtn.addEventListener('click', async () => {
      try {
        await signInAnonymously(auth);
      } catch(e){ console.error('Auth error', e); alert('Giriş başarısız: ' + e.message); }
    });

    onAuthStateChanged(auth, (user) => {
      if(user){
        me.uid = user.uid; me.nick = nickInput.value || `Komutan_${me.uid.slice(0,5)}`;
        setView('lobby');
      } else {
        setView('auth');
      }
    });

    // ---------------------------
    // Lobby / Rooms
    // ---------------------------
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomIdInput = document.getElementById('joinRoomId');
    const joinRoomBtn = document.getElementById('joinRoomBtn');

    let currentRoomId = null; let isHost = false; let roomMeta = null; let startedAt = null;

    function randId(n=8){ const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<n;i++){ s += chars[(Math.random()*chars.length)|0]; } return s; }

    async function createRoom(){
      const roomId = randId(8);
      const seed = (Math.random()*1e9|0) ^ Date.now();
      const roomRef = ref(db, `rooms/${roomId}`);
      const meta = { createdAt: Date.now(), seed, tickRate:10, inputDelay:3, hostUid: me.uid, stateEveryNTicks:20 };
      await set(child(roomRef, 'meta'), meta);
      // join as host (p1)
      await set(child(roomRef, `players/${me.uid}`), { nick: me.nick, side:'p1', ready:false, lastAckTick:0 });
      currentRoomId = roomId; isHost = true; roomMeta = meta;
      await set(child(roomRef, `presence/${me.uid}`), { online:true, lastSeen: Date.now() });
      try{ onDisconnect(child(roomRef, `presence/${me.uid}`)).set({ online:false, lastSeen: Date.now() }); }catch{}
      enterRoom(roomId);
    }

    async function joinRoom(roomId){
      const roomRef = ref(db, `rooms/${roomId}`);
      const snap = await get(child(roomRef, 'meta'));
      if(!snap.exists()){ alert('Oda bulunamadı.'); return; }
      const meta = snap.val();
      roomMeta = meta; currentRoomId = roomId; isHost = meta.hostUid === me.uid;
      // Determine side
      const playersSnap = await get(child(roomRef, 'players'));
      const players = playersSnap.exists()? playersSnap.val():{};
      const takenSides = new Set(Object.values(players).map(p=>p.side));
      const mySide = takenSides.has('p1') ? (takenSides.has('p2') ? null : 'p2') : 'p1';
      if(!mySide){ alert('Oda dolu (2 oyuncu).'); return; }
      await set(child(roomRef, `players/${me.uid}`), { nick: me.nick, side: mySide, ready:false, lastAckTick:0 });
      await set(child(roomRef, `presence/${me.uid}`), { online:true, lastSeen: Date.now() });
      try{ onDisconnect(child(roomRef, `presence/${me.uid}`)).set({ online:false, lastSeen: Date.now() }); }catch{}
      enterRoom(roomId);
    }

    createRoomBtn.addEventListener('click', createRoom);
    joinRoomBtn.addEventListener('click', ()=> joinRoom(joinRoomIdInput.value.trim().toUpperCase()));

    // Room UI
    const playersBox = document.getElementById('playersBox');
    const roomIdBadge = document.getElementById('roomIdBadge');
    const readyToggle = document.getElementById('readyToggle');
    const startBtn = document.getElementById('startBtn');
    const backToLobby = document.getElementById('backToLobby');

    function enterRoom(roomId){
      setView('room');
      roomIdBadge.textContent = roomId;
      const base = ref(db, `rooms/${roomId}`);
      onValue(child(base, 'players'), (snap)=>{
        const players = snap.exists()? snap.val():{}; renderPlayers(players);
        const everyoneReady = Object.values(players).filter(Boolean).length===2 && Object.values(players).every(p=>p.ready);
        startBtn.classList.toggle('hidden', !(isHost && everyoneReady));
      });
      onValue(child(base, 'meta/startedAt'), (snap)=>{
        if(snap.exists()){
          startedAt = snap.val();
          setTimeout(()=> startGame(), 100); // transition
        }
      });
      onValue(child(base, 'presence'), ()=> renderPlayersPresence());
    }

    function renderPlayers(players){
      playersBox.innerHTML = '';
      Object.entries(players).forEach(([uid, p])=>{
        const card = document.createElement('div');
        card.className = 'glass rounded-2xl p-3 flex items-center justify-between';
        card.innerHTML = `<div><div class="font-semibold">${p.nick||'Anon'}</div><div class="text-xs text-[var(--muted)]">${p.side||'?'} • <span id="pres-${uid}">bekleniyor…</span></div></div><div class="tag">${uid===roomMeta.hostUid? 'Host':''}</div>`;
        playersBox.appendChild(card);
      });
    }
    async function renderPlayersPresence(){
      const snap = await get(ref(db, `rooms/${currentRoomId}/presence`));
      const presence = snap.exists()? snap.val():{};
      Object.entries(presence).forEach(([uid, pr])=>{
        const el = document.getElementById(`pres-${uid}`); if(el) el.textContent = pr.online? 'Çevrimiçi':'Çevrimdışı';
      });
    }

    readyToggle.addEventListener('change', async (e)=>{
      if(!currentRoomId) return; const path = ref(db, `rooms/${currentRoomId}/players/${me.uid}`); await update(path, { ready: e.target.checked });
    });
    startBtn.addEventListener('click', async ()=>{
      if(!isHost) return; const base = ref(db, `rooms/${currentRoomId}`);
      await update(child(base, 'meta'), { startedAt: Date.now() });
    });
    backToLobby.addEventListener('click', ()=>{ currentRoomId=null; setView('lobby'); });

    // ---------------------------
    // Game State / Simulation
    // ---------------------------
    const WORLD_M_PER_PX = 100; // 1px ~ 100m (yaklaşık)
    const NET_TICK_RATE = 10;   // 10 Hz
    const NET_DT = 1/NET_TICK_RATE; // 0.1 s
    let INPUT_DELAY = 3;        // ticks

    // RNG (deterministic)
    function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    let rand = mulberry32(123456);

    // Map & Layers
    let map, svg, beamDefs;
    const unitLayer = L.layerGroup();
    const wallLayer = L.layerGroup();
    const rangeLayer = L.layerGroup();

    // Entities
    let entities = new Map(); // id -> entity
    let nextEntityId = 1;
    let mySide = 'p1';

    // Selected
    let selectedIds = new Set();
    let selectionRect = { active:false, x0:0, y0:0, x1:0, y1:0 };

    // Economy
    const RES = { money:0, oil:0, iron:0, gold:0, grain:0, pop:0, popcap:0 };

    // Visual speed (render-only)
    let visualSpeed = 1;

    // Network/Lockstep
    let lastApprovedTick = 0; // last processed
    let hostTimer = null;

    // Commands buffer (local, to be sent)
    const localCommands = new Map(); // tick -> [cmds]

    // Queues
    const buildQueue = []; // {type:'build'|'produce', name, etaTick}

    // Combat log
    function log(msg){ const li = document.createElement('li'); li.textContent = `${new Date().toLocaleTimeString()} — ${msg}`; document.getElementById('combatLog').prepend(li); }

    // ---------------------------
    // Type Definitions
    // ---------------------------
    const UNIT_TYPES = {
      INF_RIFLE: { name:'Piyade (Tüfekli)', class:'unit', emoji:'🧍', hp:60, speed:2.0, range:300, dps:6, fireRate:5, vision:800, weapon:{beamColor:'#ff7a00'} },
      INF_MG:    { name:'Piyade (MG)', class:'unit', emoji:'🧍‍♂️', hp:70, speed:1.8, range:400, dps:10, fireRate:10, vision:900, weapon:{beamColor:'#ff7a00'} },
      INF_AT:    { name:'AT Timi', class:'unit', emoji:'🎯', hp:55, speed:1.8, range:700, dps:30, fireRate:0.5, vision:900, weapon:{beamColor:'#ffa64d'} },
      INF_AA:    { name:'AA Timi', class:'unit', emoji:'🎯', hp:55, speed:1.8, range:1000, dps:25, fireRate:0.4, vision:1000, weapon:{beamColor:'#ffcf66'} },
      APC:       { name:'APC (Taşıyıcı)', class:'unit', emoji:'🚐', hp:220, speed:12, range:500, dps:8, fireRate:2, vision:1100, weapon:{beamColor:'#ff9d3f'}, transportCapacity:20 },
      TANK:      { name:'Tank (MBT)', class:'unit', emoji:'🚗', hp:420, speed:14, range:2000, dps:45, fireRate:0.3, vision:1500, weapon:{beamColor:'#ffc266'} },
      SPG:       { name:'K/M Topçu', class:'unit', emoji:'🛠️', hp:260, speed:10, range:4000, dps:35, fireRate:0.2, vision:1600, weapon:{beamColor:'#ffb347'} },
      MLRS:      { name:'MLRS', class:'unit', emoji:'🔫', hp:240, speed:10, range:6000, dps:28, fireRate:0.15, vision:1800, weapon:{beamColor:'#ffd27f'} },
      UAV:       { name:'UAV/SiHA', class:'unit', emoji:'🛸', hp:120, speed:25, range:3000, dps:12, fireRate:1.2, vision:2200, weapon:{beamColor:'#ffae42'} },
      DOZER:     { name:'Kepçe', class:'unit', emoji:'🛠️', hp:120, speed:10, range:0, dps:0, fireRate:0, vision:800, weapon:null },
    };

    const BUILDING_TYPES = {
      HQ:       { name:'Merkez Üs', class:'building', emoji:'🏢', hp:1200, produces:['INF_RIFLE','DOZER'], popcap:20 },
      MILL:     { name:'Değirmen/Çiftlik', class:'building', emoji:'🌾', hp:300, income:{money:3, grain:4} },
      REFINERY: { name:'Rafineri', class:'building', emoji:'🛢️', hp:320, income:{oil:2} },
      MINE_FE:  { name:'Demir Madeni', class:'building', emoji:'⛏️', hp:320, income:{iron:2} },
      MINE_AU:  { name:'Altın Madeni', class:'building', emoji:'🥇', hp:320, income:{gold:1}, altTick: true },
      MARKET:   { name:'Liman/Pazar', class:'building', emoji:'🛒', hp:260, bonus:0.2 },
      BARRACKS: { name:'Kışla', class:'building', emoji:'🏋️', hp:360, produces:['INF_RIFLE','INF_MG','INF_AT','INF_AA'] },
      FACTORY:  { name:'Fabrika (Zırhlı)', class:'building', emoji:'🛠️', hp:420, produces:['APC','TANK'] },
      WORKSHOP: { name:'Atölye (Topçu)', class:'building', emoji:'🔨', hp:380, produces:['SPG','MLRS'] },
      UAVPAD:   { name:'UAV Rampası', class:'building', emoji:'🛸', hp:360, produces:['UAV'] },
    };

    // Costs
    const BUILD_COST = {
      MILL: { money:100 }, REFINERY:{ money:120 }, MINE_FE:{ money:150 }, MINE_AU:{ money:200 },
      BARRACKS:{ money:120 }, FACTORY:{ money:180, oil:40, iron:40 }, WORKSHOP:{ money:180, iron:60 }, UAVPAD:{ money:220, oil:60 }, MARKET:{ money:180 }
    };
    const UNIT_COST = {
      DOZER:{ money:70, oil:20 }, INF_RIFLE:{ money:30 }, INF_MG:{ money:50 }, INF_AT:{ money:65, iron:10 }, INF_AA:{ money:70, iron:10 },
      APC:{ money:120, oil:40, iron:40 }, TANK:{ money:220, oil:80, iron:120 }, SPG:{ money:200, oil:60, iron:100 }, MLRS:{ money:240, oil:80, iron:120 }, UAV:{ money:180, oil:60 }
    };
    const PRODUCE_TIME = { DOZER:4, INF_RIFLE:4, INF_MG:6, INF_AT:7, INF_AA:7, APC:10, TANK:12, SPG:11, MLRS:13, UAV:9 };// seconds

    // ---------------------------
    // Entity Helpers
    // ---------------------------
    function addEntity(e){ e.id = nextEntityId++; entities.set(e.id, e); createMarker(e); return e; }
    function createMarker(e){
      if(e.class==='wallseg'){ // draw as polyline
        e.poly = L.polyline([e.a, e.b], { color: e.isGate? '#14b8a6':'#60a5fa', weight: 4, opacity: 0.9, dashArray: e.locked? '6,4': null }).addTo(wallLayer);
        return;
      }
      const div = document.createElement('div'); div.className = `entity ${e.side}` + (selectedIds.has(e.id)? ' selected':'' );
      div.dataset.id = e.id;
      const em = document.createElement('div'); em.className='emoji'; em.textContent = e.emoji || '•'; div.appendChild(em);
      const icon = L.divIcon({ className:'', html: div, iconSize:[22,22], iconAnchor:[11,11] });
      e.marker = L.marker(e.pos, { icon }).addTo(unitLayer);
      e.marker.on('click', (ev)=>{ selectSingle(e.id); ev.originalEvent?.stopPropagation?.(); });
    }
    function updateMarker(e){ if(e.marker) e.marker.setLatLng(e.pos); }
    function removeEntity(e){ if(e.marker){ unitLayer.removeLayer(e.marker); } if(e.poly){ wallLayer.removeLayer(e.poly); } entities.delete(e.id); }

    function selectSingle(id){ selectedIds.clear(); selectedIds.add(id); refreshSelection(); }
    function selectAdd(id){ selectedIds.add(id); refreshSelection(); }
    function clearSelection(){ selectedIds.clear(); refreshSelection(); }

    function refreshSelection(){
      // update marker visuals
      entities.forEach(e=>{ if(e.marker){ const el = e.marker.getElement(); if(el){ el.firstChild.classList.toggle('selected', selectedIds.has(e.id)); } } });
      // range circle (show for last selected)
      rangeLayer.clearLayers();
      const lastId = Array.from(selectedIds).pop();
      const e = lastId? entities.get(lastId): null;
      if(e && e.range>0){ L.circle(e.pos, { radius: e.range, color:'#60a5fa', weight:1, opacity:0.9 }).addTo(rangeLayer); }
      updateProducePanel();
    }

    // ---------------------------
    // Map Init
    // ---------------------------
    function initMap(){
      map = L.map('map', { worldCopyJump:true, zoomControl:true, minZoom:2 });
      const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community' });
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' });
      esri.addTo(map);
      unitLayer.addTo(map); wallLayer.addTo(map); rangeLayer.addTo(map);
      map.setView([37.0, 38.8], 6);

      // Prevent browser menu on map (for right-click commands)
      map.getContainer().addEventListener('contextmenu', (e)=> e.preventDefault());

      // Beam gradient defs
      svg = map.getPanes().overlayPane.querySelector('svg');
      if(!svg){ svg = L.svg().addTo(map); svg = map.getPanes().overlayPane.querySelector('svg'); }
      beamDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      beamDefs.innerHTML = `
        <linearGradient id="beamGrad" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--beamA') || '#ff9100'}"/>
          <stop offset="100%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--beamB') || '#ffd08a'}"/>
        </linearGradient>`;
      svg.appendChild(beamDefs);

      // Map click selection clear
      map.on('click', ()=> clearSelection());

      // Left drag select
      let dragStart = null;
      map.on('mousedown', (ev)=>{
        if(ev.originalEvent.button!==0) return; // left
        dragStart = ev.containerPoint; selectionRect.active=true; selectionRect.x0 = dragStart.x; selectionRect.y0 = dragStart.y; selectionRect.x1 = dragStart.x; selectionRect.y1 = dragStart.y; updateSelectRect();
      });
      map.on('mousemove', (ev)=>{
        if(!selectionRect.active) return; selectionRect.x1 = ev.containerPoint.x; selectionRect.y1 = ev.containerPoint.y; updateSelectRect();
      });
      map.on('mouseup', (ev)=>{
        if(!selectionRect.active) return; selectionRect.active=false; $('#selectRect').classList.add('hidden');
        const minx = Math.min(selectionRect.x0, selectionRect.x1), maxx = Math.max(selectionRect.x0, selectionRect.x1);
        const miny = Math.min(selectionRect.y0, selectionRect.y1), maxy = Math.max(selectionRect.y0, selectionRect.y1);
        selectedIds.clear();
        entities.forEach(e=>{
          if(e.side!==mySide) return; if(!e.marker) return; const pt = map.latLngToContainerPoint(e.pos); if(pt.x>=minx && pt.x<=maxx && pt.y>=miny && pt.y<=maxy){ selectedIds.add(e.id); }
        });
        refreshSelection();
      });

      function updateSelectRect(){
        const el = $('#selectRect'); el.classList.toggle('hidden', !selectionRect.active);
        if(!selectionRect.active) return;
        const x = Math.min(selectionRect.x0, selectionRect.x1);
        const y = Math.min(selectionRect.y0, selectionRect.y1);
        const w = Math.abs(selectionRect.x1 - selectionRect.x0);
        const h = Math.abs(selectionRect.y1 - selectionRect.y0);
        el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.width = w + 'px'; el.style.height = h + 'px';
      }

      // Right-click: move/attack
      map.on('contextmenu', (ev)=>{ handleRightClick(ev.latlng); });
    }

    function handleRightClick(latlng){
      if(selectedIds.size===0){ hint('Önce birim seçin'); return; }
      // Check enemy under cursor (within 10px)
      let enemy = null; let minD=1e9;
      entities.forEach(e=>{
        if(e.side && e.side!==mySide){ const p = map.latLngToContainerPoint(e.pos); const q = map.latLngToContainerPoint(latlng); const d = Math.hypot(p.x-q.x, p.y-q.y); if(d<12 && d<minD){ minD=d; enemy=e; } }
      });
      if(enemy){ issueCmd('ATTACK', { unitIds:[...selectedIds], targetId: enemy.id }); hint('Saldırı emri verildi'); }
      else { issueCmd('MOVE', { unitIds:[...selectedIds], target: latlng }); hint('Hareket emri verildi'); }
    }

    // ---------------------------
    // Commands / Network
    // ---------------------------
    function nowTick(){ return Math.floor((Date.now() - startedAt) / (NET_DT*1000)); }

    function queueLocal(tick, cmd){ if(!localCommands.has(tick)) localCommands.set(tick, []); localCommands.get(tick).push(cmd); sendLocal(tick); }

    async function sendLocal(tick){
      // Write only to own path
      const path = ref(db, `rooms/${currentRoomId}/commands/${tick}/${me.uid}`);
      const cmds = localCommands.get(tick) || [];
      await set(path, { cmds });
    }

    function issueCmd(type, payload){
      const t = nowTick(); const targetTick = t + INPUT_DELAY; if(targetTick <= t){ console.warn('Past tick blocked'); return; }
      const cmd = { type, payload };
      queueLocal(targetTick, cmd);
    }

    // Host: merge per tick to approved
    async function hostLoop(){
      const t = nowTick();
      // Approve up to t (current tick). For each missing tick, write merged (even if empty)
      for(let k = lastHostApprovedTick + 1; k <= t; k++){
        const approvedRef = ref(db, `rooms/${currentRoomId}/approved/${k}`);
        const approvedSnap = await get(approvedRef);
        if(approvedSnap.exists()){ lastHostApprovedTick = k; continue; }
        const cmdsSnap = await get(ref(db, `rooms/${currentRoomId}/commands/${k}`));
        let merged = [];
        if(cmdsSnap.exists()){
          const obj = cmdsSnap.val();
          Object.values(obj).forEach(v=>{ if(v && Array.isArray(v.cmds)) merged.push(...v.cmds); });
        }
        // normalize: dedup per unit per type (keep last)
        const norm = new Map();
        merged.forEach((c,i)=>{
          const key = c.type+ '|' + (c.payload.unitIds? c.payload.unitIds.join(','):'') + '|' + (c.payload.targetId||'') + '|' + (c.payload.buildingType||'') + '|' + (c.payload.unitType||'');
          norm.set(key, c);
        });
        merged = Array.from(norm.values());
        await set(approvedRef, { merged });
        lastHostApprovedTick = k;
      }
    }

    function subscribeApproved(){
      const qref = ref(db, `rooms/${currentRoomId}/approved`);
      onChildAdded(qref, (snap)=>{
        const k = parseInt(snap.key); const { merged } = snap.val();
        // Apply tick sequentially
        if(k === lastApprovedTick + 1){ applyTick(k, merged); lastApprovedTick = k; }
        else if(k > lastApprovedTick + 1){
          // if late arrival, simulate missing ticks as empty until k-1, then apply k
          for(let m=lastApprovedTick+1; m<k; m++){ applyTick(m, []); }
          applyTick(k, merged); lastApprovedTick = k;
        }
      });
    }

    // ---------------------------
    // Simulation Core
    // ---------------------------
    function vecDistance(a,b){ return map.distance(a,b); }
    function moveTowards(pos, target, speed, dt){
      const d = vecDistance(pos, target); if(d < 1) return pos;
      const m = (speed*dt) / d; if(m >= 1) return target; // reached
      const lat = pos.lat + (target.lat - pos.lat) * m;
      const lng = pos.lng + (target.lng - pos.lng) * m;
      return L.latLng(lat, lng);
    }

    function lineIntersectsWalls(a,b, side){
      let hit=null; wallLayer.eachLayer(poly=>{
        const latlngs = poly.getLatLngs(); const s = {a:latlngs[0], b:latlngs[1]};
        // If gate and (open or same side), allow pass
        const e = Array.from(entities.values()).find(x=> x.poly===poly);
        if(e && e.isGate && !e.locked) return; // open gate
        if(segmentsIntersect(a,b,s.a,s.b)) hit = { e, seg:s };
      });
      return hit;
    }
    function segmentsIntersect(p1,p2,p3,p4){
      function ccw(a,b,c){ return (c.lat - a.lat)*(b.lng - a.lng) > (b.lat - a.lat)*(c.lng - a.lng); }
      return (ccw(p1,p3,p4) !== ccw(p2,p3,p4)) && (ccw(p1,p2,p3) !== ccw(p1,p2,p4));
    }

    function simulate(dt){
      // movement + basic targeting
      entities.forEach(e=>{
        if(e.class!== 'unit') return;
        if(e.hp<=0){ removeEntity(e); return; }
        // Transported units hidden
        if(e.hidden) return;
        // Pathing: simple direct; if wall blocks, detour via segment endpoint
        if(e.moveTarget){
          let target = e.moveTarget;
          const hit = lineIntersectsWalls(e.pos, target, e.side);
          if(hit){ // detour via nearest endpoint
            const a=hit.seg.a, b=hit.seg.b;
            const da = vecDistance(e.pos,a), db = vecDistance(e.pos,b);
            e.waypoint = (da<db? a:b);
          }
          if(e.waypoint){
            e.pos = moveTowards(e.pos, e.waypoint, e.speed, dt);
            if(vecDistance(e.pos, e.waypoint) < 3){ e.waypoint=null; }
          } else {
            e.pos = moveTowards(e.pos, target, e.speed, dt);
            if(vecDistance(e.pos, target) < 3){ e.moveTarget=null; }
          }
          updateMarker(e);
        }
        // Targeting
        if(!e.targetId || !entities.has(e.targetId) || entities.get(e.targetId).side===e.side){ e.targetId = null; }
        let tgt = e.targetId? entities.get(e.targetId): null;
        if(!tgt){ // find nearest enemy within threat (range + 50)
          let best=null, bd=1e9; entities.forEach(o=>{
            if(o.side && o.side!==e.side){ const d = vecDistance(e.pos, o.pos); if(d < (e.range+50) && d<bd){ bd=d; best=o; } }
          });
          if(best) e.targetId = best.id, tgt=best;
        }
        // Attack if in range
        if(tgt){
          const d = vecDistance(e.pos, tgt.pos);
          if(d <= e.range){ e.cooldown = (e.cooldown||0) - dt; if(e.cooldown<=0){
            // Fire!
            const dmg = e.fireRate>0? (e.dps / e.fireRate) : 0;
            tgt.hp -= dmg; if(tgt.hp<=0){ log(`${e.name} hedefi imha etti: ${tgt.name}`); removeEntity(tgt); }
            drawBeam(e.pos, tgt.pos);
            e.cooldown = e.fireRate>0? (1/e.fireRate) : 0.5;
          } }
          else { // move closer
            e.moveTarget = tgt.pos;
          }
        }
      });

      // Economy tick every 3s (30 ticks @10Hz)
      econTimer += dt;
      if(econTimer >= 3){ econTimer = 0; distributeIncome(); }

      // Production timers
      for(let i=buildQueue.length-1;i>=0;i--){ const q = buildQueue[i]; q.eta -= dt; if(q.eta <= 0){ if(q.type==='produce'){ spawnUnitNear(q.buildingId, q.unitType); log(`Üretim tamamlandı: ${q.unitType}`); } buildQueue.splice(i,1); refreshQueue(); } }
    }

    let econTimer = 0;
    function distributeIncome(){
      let income = { money:0, oil:0, iron:0, gold:0, grain:0 };
      let marketCount = 0; let goldToggle=false;
      entities.forEach(e=>{
        if(e.class==='building' && e.side===mySide){
          if(e.type==='MARKET'){ marketCount++; }
          const bt = BUILDING_TYPES[e.type];
          if(bt && bt.income){
            income.money += bt.income.money||0;
            income.oil   += bt.income.oil||0;
            income.iron  += bt.income.iron||0;
            if(bt.altTick){ goldToggle = !goldToggle; if(goldToggle) income.gold += bt.income.gold||0; }
            else income.gold += bt.income.gold||0;
            income.grain += bt.income.grain||0;
          }
        }
      });
      const bonus = Math.min(marketCount*0.2, 0.6);
      RES.money += Math.round(income.money * (1+bonus));
      RES.oil   += income.oil; RES.iron += income.iron; RES.gold += income.gold; RES.grain += income.grain;
      updateHUD();
    }

    function updateHUD(){ $('#r-money').textContent = RES.money|0; $('#r-oil').textContent = RES.oil|0; $('#r-iron').textContent = RES.iron|0; $('#r-gold').textContent = RES.gold|0; $('#r-grain').textContent = RES.grain|0; $('#r-pop').textContent = RES.pop|0; $('#r-popcap').textContent = RES.popcap|0; }

    function drawBeam(fromLatLng, toLatLng){
      // convert to svg coords
      const p1 = map.latLngToLayerPoint(fromLatLng); const p2 = map.latLngToLayerPoint(toLatLng);
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y); line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
      line.setAttribute('stroke', 'url(#beamGrad)'); line.setAttribute('stroke-width', '3'); line.setAttribute('opacity','0.9'); line.classList.add('beam');
      svg.appendChild(line);
      const dur = (150 / visualSpeed)|0; // 120–180ms -> 150ms base
      setTimeout(()=>{ line.setAttribute('opacity','0.0'); }, dur*0.6);
      setTimeout(()=>{ if(line.parentNode) line.parentNode.removeChild(line); }, dur);
    }

    // ---------------------------
    // Build / Produce UI
    // ---------------------------
    const buildPanel = document.getElementById('buildPanel');
    function renderBuildButtons(){
      buildPanel.innerHTML = '';
      const list = [
        ['MİMARİ', [ ['MILL','Değirmen (💰100)'], ['REFINERY','Rafineri (💰120)'], ['MINE_FE','Demir Madeni (💰150)'], ['MINE_AU','Altın Madeni (💰200)'], ['MARKET','Liman/Pazar (💰180)'] ]],
        ['ASKERİ', [ ['BARRACKS','Kışla (💰120)'], ['FACTORY','Fabrika (💰180+🛢️40+⛓️40)'], ['WORKSHOP','Atölye (💰180+⛓️60)'], ['UAVPAD','UAV Rampası (💰220+🛢️60)'] ]],
        ['SAVUNMA', [ ['WALL','Duvar/Kapı (100m başına 💰10)'] ]]
      ];
      list.forEach(([title, items])=>{
        const h = document.createElement('div'); h.className='text-xs uppercase tracking-wide text-[var(--muted)] mt-2'; h.textContent=title; buildPanel.appendChild(h);
        items.forEach(([k, label])=>{
          const b = document.createElement('button'); b.className='btn w-full text-left'; b.textContent = label; b.addEventListener('click', ()=> onBuildClick(k)); buildPanel.appendChild(b);
        });
      });
    }

    let wallDraw = { active:false, pts:[], isGate:false };
    function onBuildClick(k){
      if(k==='WALL'){
        wallDraw.active = !wallDraw.active; wallDraw.pts = []; wallDraw.isGate = false; hint(wallDraw.active? 'Duvar çizim: noktaları tıklayın, çift tıkla bitir. G tuşu kapı toggler.':'Duvar modu kapalı');
        if(wallDraw.active){ map.on('click', wallAddPt); map.on('dblclick', wallFinish); window.addEventListener('keydown', wallKey); }
        else { map.off('click', wallAddPt); map.off('dblclick', wallFinish); window.removeEventListener('keydown', wallKey); }
        return;
      }
      // Place building at map center
      const center = map.getCenter();
      issueCmd('BUILD', { buildingType: k, at: center });
    }

    function wallKey(ev){ if(ev.key==='g' || ev.key==='G'){ wallDraw.isGate = !wallDraw.isGate; hint('Kapı: '+ (wallDraw.isGate?'AÇIK':'KAPALI (kilit)')); } }
    function wallAddPt(ev){ wallDraw.pts.push(ev.latlng); }
    function wallFinish(){
      if(wallDraw.pts.length<2){ hint('En az 2 nokta gerekli'); return; }
      issueCmd('WALL', { poly: wallDraw.pts, isGate: wallDraw.isGate });
      wallDraw.active=false; wallDraw.pts=[]; map.off('click', wallAddPt); map.off('dblclick', wallFinish); window.removeEventListener('keydown', wallKey);
      hint('Duvar kuyruğa alındı');
    }

    function updateProducePanel(){
      const producePanel = document.getElementById('producePanel');
      const buttons = document.getElementById('produceButtons');
      // Find selected building with produces
      let bld = null; for(const id of selectedIds){ const e = entities.get(id); if(e && e.class==='building'){ const bt = BUILDING_TYPES[e.type]; if(bt && bt.produces){ bld = e; break; } } }
      if(!bld){ producePanel.classList.add('hidden'); return; }
      producePanel.classList.remove('hidden'); buttons.innerHTML = '';
      const bt = BUILDING_TYPES[bld.type];
      bt.produces.forEach(u =>{
        const cost = UNIT_COST[u];
        const capWarn = (u.startsWith('INF')? '👥' : '');
        const b = document.createElement('button'); b.className='btn w-full text-left'; b.textContent = `${UNIT_TYPES[u].name} (${renderCost(cost)}) ${capWarn}`;
        b.addEventListener('click', ()=> issueCmd('PRODUCE', { buildingId: bld.id, unitType: u }));
        buttons.appendChild(b);
      });
    }
    function renderCost(c){ return [c.money?'💰'+c.money:'', c.oil?'🛢️'+c.oil:'', c.iron?'⛓️'+c.iron:''].filter(Boolean).join(' '); }

    // Queue UI
    function refreshQueue(){ const ul = document.getElementById('queueList'); ul.innerHTML=''; buildQueue.forEach(q=>{ const li=document.createElement('li'); li.textContent = `${q.name} — ${(Math.max(0,q.eta)).toFixed(1)} sn`; ul.appendChild(li); }); }

    // ---------------------------
    // Apply Tick (lockstep)
    // ---------------------------
    function applyTick(tick, cmds){
      // Apply commands first
      cmds.forEach(c=>{
        switch(c.type){
          case 'MOVE': c.payload.unitIds.forEach(id=>{ const e = entities.get(id); if(e && e.side===mySide){ e.moveTarget = L.latLng(c.payload.target.lat, c.payload.target.lng); } }); break;
          case 'ATTACK': c.payload.unitIds.forEach(id=>{ const e = entities.get(id); if(e && e.side===mySide){ e.targetId = c.payload.targetId; } }); break;
          case 'BUILD': handleBuild(c.payload); break;
          case 'WALL': handleWall(c.payload); break;
          case 'PRODUCE': handleProduce(c.payload); break;
          case 'TRANSPORT': handleTransport(c.payload); break;
        }
      });
      // Simulate once per tick
      simulate(NET_DT);
      // Victory check
      const myHQ = Array.from(entities.values()).find(e=> e.type==='HQ' && e.side===mySide);
      const enHQ = Array.from(entities.values()).find(e=> e.type==='HQ' && e.side!==mySide);
      if(!myHQ || myHQ.hp<=0){ showResult(false); }
      if(!enHQ || enHQ.hp<=0){ showResult(true); }
    }

    function handleBuild(p){
      const type = p.buildingType;
      if(type==='WALL') return; // handled by WALL
      const cost = BUILD_COST[type];
      if(!canAfford(cost)){ hint('Yetersiz kaynak'); return; }
      pay(cost); updateHUD();
      const bt = BUILDING_TYPES[type];
      const e = addEntity({ name:bt.name, type, class:'building', side: mySide, pos: L.latLng(p.at.lat, p.at.lng), emoji: bt.emoji, hp: bt.hp });
      if(bt.popcap){ RES.popcap += bt.popcap; updateHUD(); }
    }

    function handleWall(p){
      // Split into segments
      const pts = p.poly.map(ll=> L.latLng(ll.lat, ll.lng));
      for(let i=0;i<pts.length-1;i++){
        const a=pts[i], b=pts[i+1];
        const length = vecDistance(a,b); const cost = { money: Math.ceil((length/100) * 10) };
        if(!canAfford(cost)){ hint('Duvar için kaynak yetersiz'); break; }
        pay(cost);
        addEntity({ class:'wallseg', name: p.isGate? 'Kapı':'Duvar', type: p.isGate?'GATE':'WALL', isGate:p.isGate, locked:!p.isGate, a, b, hp:400 });
      }
      updateHUD();
    }

    function handleProduce(p){
      const { buildingId, unitType } = p; const bld = entities.get(buildingId); if(!bld) return;
      const cost = UNIT_COST[unitType]; if(!canAfford(cost)){ hint('Üretim için kaynak yetersiz'); return; }
      pay(cost); updateHUD();
      const eta = PRODUCE_TIME[unitType];
      buildQueue.push({ type:'produce', name: UNIT_TYPES[unitType].name, buildingId, unitType, eta });
      refreshQueue();
    }

    function handleTransport(p){
      const carrier = entities.get(p.carrierId); if(!carrier) return;
      if(p.action==='load'){
        const nearby = []; entities.forEach(e=>{ if(e.side===mySide && e.class==='unit' && e.type.startsWith('INF')){ const d = vecDistance(carrier.pos, e.pos); if(d<200) nearby.push(e); } });
        const capacity = (carrier.transportCapacity||0) - (carrier.cargo? carrier.cargo.length:0);
        const pick = nearby.slice(0, capacity);
        carrier.cargo = carrier.cargo || [];
        pick.forEach(u=>{ carrier.cargo.push(u.id); u.hidden=true; if(u.marker){ unitLayer.removeLayer(u.marker); u.marker=null; } });
        hint('APC: '+pick.length+' asker bindirildi');
      } else if(p.action==='unload'){
        if(!carrier.cargo||carrier.cargo.length===0){ hint('APC boş'); return; }
        const ids = carrier.cargo.splice(0);
        ids.forEach(id=>{ const u = entities.get(id); if(u){ u.hidden=false; u.pos = jitterAround(carrier.pos, 30); createMarker(u); } });
        hint('APC: askerler indirildi');
      }
    }

    function jitterAround(latlng, meters){
      const dLat = (Math.random()-0.5)*meters*1e-5; const dLng = (Math.random()-0.5)*meters*1e-5; return L.latLng(latlng.lat + dLat, latlng.lng + dLng);
    }

    function canAfford(cost){ return (!cost.money || RES.money>=cost.money) && (!cost.oil || RES.oil>=cost.oil) && (!cost.iron || RES.iron>=cost.iron); }
    function pay(cost){ RES.money = (RES.money||0) - (cost.money||0); RES.oil = (RES.oil||0)-(cost.oil||0); RES.iron=(RES.iron||0)-(cost.iron||0); }

    function spawnUnitNear(buildingId, unitType){
      const b = entities.get(buildingId); if(!b) return; const udef = UNIT_TYPES[unitType];
      const u = addEntity({ name: udef.name, type:unitType, class:'unit', side: mySide, pos: jitterAround(b.pos, 60), emoji: udef.emoji, hp: udef.hp, speed: udef.speed, range: udef.range, dps: udef.dps, fireRate: udef.fireRate, transportCapacity: udef.transportCapacity||0 });
      RES.pop += unitType.startsWith('INF')? 1: 0; updateHUD();
    }

    // ---------------------------
    // Game Init (deterministic spawns)
    // ---------------------------
    function initSim(seed){
      rand = mulberry32(seed>>>0);
      nextEntityId = 1; entities.clear(); unitLayer.clearLayers(); wallLayer.clearLayers(); rangeLayer.clearLayers();
      // sides
      mySide = (roomMeta && roomMeta.hostUid === me.uid)? 'p1' : ( (()=>{ /* find my player side from room */ return 'p2'; })() );
      // Derive mySide from DB players
      // We'll fetch synchronously (best effort)
      get(ref(db, `rooms/${currentRoomId}/players/${me.uid}/side`)).then(s=>{ if(s.exists()) mySide = s.val(); });

      // spawn around two positions ~ 6km apart
      const baseCenter = L.latLng( 37 + (rand()-0.5)*0.6, 38.8 + (rand()-0.5)*0.6 );
      const dlat = 0.06, dlng = 0.08; // ~km offsets
      const p1pos = L.latLng(baseCenter.lat + dlat, baseCenter.lng - dlng);
      const p2pos = L.latLng(baseCenter.lat - dlat, baseCenter.lng + dlng);

      function spawnSet(side, at){
        const HQ = addEntity({ name:'Merkez Üs', type:'HQ', class:'building', side, pos: at, emoji:'🏢', hp:1200 });
        const BARR = addEntity({ name:'Kışla', type:'BARRACKS', class:'building', side, pos: jitterAround(at, 120), emoji:'🏋️', hp:360 });
        const MILL = addEntity({ name:'Değirmen', type:'MILL', class:'building', side, pos: jitterAround(at, 180), emoji:'🌾', hp:300 });
        // Units
        addEntity({ name:'Kepçe', type:'DOZER', class:'unit', side, pos: jitterAround(at, 120), emoji:'🛠️', hp:120, speed:10, range:0, dps:0, fireRate:0, transportCapacity:0 });
        for(let i=0;i<6;i++) addEntity({ name:'Piyade', type:'INF_RIFLE', class:'unit', side, pos: jitterAround(at, 160), emoji:'🧍', hp:60, speed:2.0, range:300, dps:6, fireRate:5 });
        addEntity({ name:'APC', type:'APC', class:'unit', side, pos: jitterAround(at, 140), emoji:'🚐', hp:220, speed:12, range:500, dps:8, fireRate:2, transportCapacity:20 });
        addEntity({ name:'Tank', type:'TANK', class:'unit', side, pos: jitterAround(at, 200), emoji:'🚗', hp:420, speed:14, range:2000, dps:45, fireRate:0.3 });
      }
      spawnSet('p1', p1pos); spawnSet('p2', p2pos);

      // Starting resources
      RES.money=300; RES.oil=120; RES.iron=120; RES.gold=10; RES.grain=40; RES.pop=7; RES.popcap=20; updateHUD();

      renderBuildButtons();
    }

    // ---------------------------
    // Game Start / Loop
    // ---------------------------
    function startGame(){
      setView('game');
      $('#topbar').classList.remove('hidden');
      initMap();
      INPUT_DELAY = roomMeta?.inputDelay || 3;
      initSim(roomMeta?.seed || 123456);
      subscribeApproved();
      // Host timer
      if(roomMeta.hostUid === me.uid){
        lastHostApprovedTick = 0;
        hostTimer = setInterval(hostLoop, NET_DT*1000);
      }
      // Render loop
      let last=performance.now();
      function frame(ts){ const dt = Math.min(0.05, (ts-last)/1000) * visualSpeed; last=ts; // visual only
        // nothing heavy (sim done in ticks)
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    function showResult(win){
      $('#resultTitle').textContent = win? 'Zafer!':'Yenilgi';
      $('#resultSub').textContent = win? 'Düşman HQ yok edildi.' : 'HQ yok edildi.';
      $('#resultModal').classList.add('show');
    }

    // ---------------------------
    // UI Buttons & Shortcuts
    // ---------------------------
    document.getElementById('toggleBuild').onclick = ()=>{
      const el = document.getElementById('buildPanel'); el.classList.toggle('hidden');
    };
    document.getElementById('helpBtn').onclick = ()=> $('#helpModal').classList.add('show');
    document.getElementById('helpClose').onclick = ()=> $('#helpModal').classList.remove('show');
    document.getElementById('resultOk').onclick = ()=>{ $('#resultModal').classList.remove('show'); setView('lobby'); };
    document.getElementById('leaveBtn').onclick = ()=>{ setView('lobby'); };

    document.getElementById('speed1').onclick = ()=>{ visualSpeed=1; hint('Görsel hız 1x'); };
    document.getElementById('speed5').onclick = ()=>{ visualSpeed=5; hint('Görsel hız 5x'); };
    document.getElementById('speed10').onclick = ()=>{ visualSpeed=10; hint('Görsel hız 10x'); };

    // Mobile
    document.getElementById('mMove').onclick = ()=>{ hint('Hareket modu: haritaya dokunun'); const once=(e)=>{ handleRightClick(e.latlng); map.off('click', once); }; map.on('click', once); };
    document.getElementById('mAttack').onclick = ()=>{ hint('Saldırı: düşmana dokunun'); };
    document.getElementById('mStop').onclick = ()=>{ selectedIds.forEach(id=>{ const e=entities.get(id); if(e) e.moveTarget=null; }); };

    // Keyboard
    window.addEventListener('keydown', (ev)=>{
      if(ev.key==='h' || ev.key==='H'){ $('#helpModal').classList.add('show'); }
      if(ev.key==='1'){ visualSpeed=1; }
      if(ev.key==='5'){ visualSpeed=5; }
      if(ev.key==='0'){ visualSpeed=10; }
      if(ev.key==='k' || ev.key==='K'){
        // toggle selected gate lock
        for(const id of selectedIds){ const e = entities.get(id); if(e && e.class==='wallseg' && e.isGate){ e.locked = !e.locked; if(e.poly) e.poly.setStyle({ dashArray: e.locked? '6,4': null, color: e.locked? '#0284c7':'#14b8a6' }); }}
      }
    });

    // ---------------------------
    // EXTRA: Produce toolbar for APC load/unload if selected
    // ---------------------------
    // Add small toolbar under left panel when APC selected
    const produceButtons = document.getElementById('produceButtons');
    const producePanel = document.getElementById('producePanel');

    // Extend produce panel with APC controls when APC selected
    const apcTools = document.createElement('div'); apcTools.className='mt-2 flex gap-2';
    const loadBtn = document.createElement('button'); loadBtn.className='btn flex-1'; loadBtn.textContent='APC: Bindir'; loadBtn.onclick = ()=>{
      const apc = Array.from(selectedIds).map(id=>entities.get(id)).find(e=> e && e.type==='APC'); if(apc) issueCmd('TRANSPORT', { carrierId: apc.id, action:'load' });
    };
    const unloadBtn = document.createElement('button'); unloadBtn.className='btn flex-1'; unloadBtn.textContent='APC: İndir'; unloadBtn.onclick = ()=>{
      const apc = Array.from(selectedIds).map(id=>entities.get(id)).find(e=> e && e.type==='APC'); if(apc) issueCmd('TRANSPORT', { carrierId: apc.id, action:'unload' });
    };
    apcTools.appendChild(loadBtn); apcTools.appendChild(unloadBtn); producePanel.appendChild(apcTools);

    // Observe selection changes to show/hide APC tools
    const _refreshSelection = refreshSelection;
    refreshSelection = function(){ _refreshSelection(); const hasAPC = Array.from(selectedIds).some(id=>{ const e=entities.get(id); return e && e.type==='APC'; }); apcTools.style.display = hasAPC? 'flex':'none'; };

  </script>
</body>
</html>
