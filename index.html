<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Global RTS — Üs Kur, Üret, Saldır!</title>

  <!-- MAP & UI LIBS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0b1220; --panel:#111A2B; --panel2:#0F1626; --accent:#34d399; --accent2:#60a5fa; --danger:#ef4444; --warning:#f59e0b; --text:#E6EDF6;
    }
    html,body{height:100%; background:var(--bg); color:var(--text); font-family:'Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}
    #app{height:100%; display:grid; grid-template-rows:auto 1fr auto}
    #map{height:100%; width:100%}

    /* HUD */
    .glass{backdrop-filter: blur(10px); background: linear-gradient(180deg, rgba(17,26,43,.8), rgba(11,18,32,.8)); border:1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.35)}
    .btn{display:inline-flex; align-items:center; gap:.5rem; padding:.5rem .8rem; border-radius:.75rem; border:1px solid rgba(255,255,255,.06); transition:.2s transform, .2s background, .2s border}
    .btn:hover{transform:translateY(-1px); border-color: rgba(255,255,255,.12)}
    .btn:active{transform:translateY(0)}
    .btn[disabled]{opacity:.45; pointer-events:none}

    .tag{font-size:.75rem; padding:.15rem .5rem; border-radius:.4rem; border:1px solid rgba(255,255,255,.1)}

    /* Marker icons via DIVs so we can style/animate */
    .unit, .building{ position:relative; display:flex; align-items:center; justify-content:center; font-weight:800; color:#fff; border-radius:999px; border:2px solid rgba(0,0,0,.3); box-shadow:0 8px 20px rgba(0,0,0,.35)}
    .unit{ width:22px; height:22px; font-size:12px }
    .building{ width:28px; height:28px; font-size:14px }
    .player{ background: radial-gradient(circle at 30% 30%, #10b981 10%, #059669 80%) }
    .ai{ background: radial-gradient(circle at 30% 30%, #60a5fa 10%, #2563eb 80%) }
    .neutral{ background: #6b7280 }
    .kepce::after{ content:"⛏️"; filter: drop-shadow(0 1px 0 rgba(0,0,0,.5)); }
    .soldier::after{ content:"🪖" }
    .tank::after{ content:"🛡️" }
    .ship::after{ content:"🚢" }
    .base::after{ content:"🏰" }
    .mill::after{ content:"🌾" }
    .refinery::after{ content:"🛢️" }
    .port::after{ content:"⚓" }
    .factory::after{ content:"🏭" }
    .barracks::after{ content:"🎖️" }

    /* Selection ring */
    .sel{ outline:3px solid rgba(255,255,255,.7); outline-offset:2px; animation:pulse 1.2s ease-in-out infinite }
    @keyframes pulse{ 0%{outline-color:rgba(255,255,255,.7)} 50%{outline-color:rgba(255,255,255,.2)} 100%{outline-color:rgba(255,255,255,.7)} }

    /* Healthbar */
    .hpbar{ position:absolute; bottom:-4px; left: 50%; width: 44px; height:3px; background:rgba(255,255,255,.15); border-radius: 999px; overflow:hidden; transform: translateX(-50%)}
    .hpfill{ height:100%; background: linear-gradient(90deg, #22c55e, #16a34a) }

    /* Build progress bar */
    .buildbar{ position:absolute; top:-6px; left:50%; width:44px; height:4px; background:rgba(255,255,255,.1); border-radius:999px; overflow:hidden; transform: translateX(-50%);}    
    .buildfill{ height:100%; background: linear-gradient(90deg, #f59e0b, #fde047) }

    /* Attack beam */
    .beam{ stroke:#fef08a; stroke-width:2; stroke-linecap:round; filter: drop-shadow(0 0 6px rgba(250,204,21,.9)); opacity:.95; pointer-events:none }

    /* Modal */
    .modal{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.5); z-index:9999 }
    .modal.show{ display:grid }

    /* Leaflet tweaks */
    .leaflet-container{ background:#0b1220 }
    .leaflet-control-zoom{ border:none }
    .leaflet-bar a{ background:var(--panel); color:#fff; border:none }
    .leaflet-bar a:hover{ background:#1b2741 }
  </style>
</head>
<body>
<div id="app">
  <!-- TOP HUD -->
  <header class="glass z-[5000] sticky top-0 w-full">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-wrap gap-3 items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="text-xl font-extrabold tracking-wide">GLOBAL <span class="text-emerald-400">RTS</span></div>
        <div class="hidden md:flex items-center gap-2 text-sm opacity-80">
          <span class="tag bg-emerald-500/10 border-emerald-400/30">Uydu Haritası</span>
          <span class="tag bg-sky-500/10 border-sky-400/30">Canlı Savaş</span>
          <span class="tag bg-yellow-500/10 border-yellow-400/30">AI Rakip</span>
        </div>
      </div>
      <div class="flex flex-wrap gap-3 items-center">
        <div class="glass rounded-xl px-3 py-2 flex items-center gap-5 text-sm">
          <div class="flex items-center gap-1"><span class="opacity-70">💰 Para:</span> <span id="money" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🛢️ Petrol:</span> <span id="oil" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🔧 Kepçe:</span> <span id="excCount" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🪖 Asker:</span> <span id="soldierCount" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🛡️ Tank:</span> <span id="tankCount" class="font-bold">0</span></div>
          <div class="flex items-center gap-1"><span class="opacity-70">🚢 Gemi:</span> <span id="shipCount" class="font-bold">0</span></div>
        </div>
        <div class="glass rounded-xl px-3 py-2 text-xs flex items-center gap-2">
          <span>⏩ Hız:</span>
          <input id="speedRange" type="range" min="1" max="100" value="1" class="w-32"/>
          <span id="speedLbl" class="font-bold">1x</span>
          <div class="hidden sm:flex items-center gap-1 ml-2">
            <button class="btn bg-white/10" data-speed="1">1x</button>
            <button class="btn bg-white/10" data-speed="2">2x</button>
            <button class="btn bg-white/10" data-speed="5">5x</button>
            <button class="btn bg-white/10" data-speed="10">10x</button>
            <button class="btn bg-white/10" data-speed="50">50x</button>
            <button class="btn bg-white/10" data-speed="100">100x</button>
          </div>
        </div>
        <div class="glass rounded-xl px-3 py-2 text-xs flex items-center gap-2">
          <span>🎯 Davranış:</span>
          <button id="stanceBtn" class="btn bg-emerald-500/15">Agresif</button>
        </div>
        <button id="newGame" class="btn bg-emerald-500/20 border-emerald-400/30">↻ Yeni Oyun</button>
        <button id="helpBtn" class="btn bg-sky-500/20 border-sky-400/30">❔ Yardım</button>
        <button id="runTests" class="btn bg-white/10">🧪 Test</button>
      </div>
    </div>
  </header>

  <!-- MAP -->
  <main class="relative">
    <div id="map"></div>

    <!-- LEFT ACTION BAR -->
    <div class="glass rounded-2xl p-3 absolute left-3 top-3 z-[5000] w-[280px]">
      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">İnşa Et</div>
      <div class="grid grid-cols-2 gap-2 mb-3">
        <button class="btn bg-white/5 hover:bg-white/10" data-build="mill">🌾 Değirmen <span class="opacity-70 text-xs">(💰100)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="refinery">🛢️ Rafineri <span class="opacity-70 text-xs">(💰50)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="port">⚓ Liman <span class="opacity-70 text-xs">(💰200)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10" data-build="barracks">🎖️ Kışla <span class="opacity-70 text-xs">(💰100)</span></button>
        <button class="btn bg-white/5 hover:bg-white/10 col-span-2" data-build="factory">🏭 Tank Fabrikası <span class="opacity-70 text-xs">(💰150 + 🛢️50)</span></button>
      </div>

      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Üret (Seçili Bina)</div>
      <div id="prodPanel" class="grid grid-cols-1 gap-2 text-sm">
        <div class="opacity-60">Bir bina seçin…</div>
      </div>
      <div class="mt-3 text-xs opacity-70">İpucu: Bir <b>bina</b> seçtiğinde buradan üretim yapabilirsin. <b>Base</b>: Kepçe • <b>Kışla</b>: Asker • <b>Fabrika</b>: Tank • <b>Liman</b>: Gemi</div>
    </div>

    <!-- RIGHT PANEL: QUEUE & LOG -->
    <div class="glass rounded-2xl p-3 absolute right-3 top-3 z-[5000] w-[320px]">
      <div class="text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Kepçe Görev Kuyruğu</div>
      <ul id="queue" class="space-y-1 text-sm"></ul>
      <div class="mt-3 text-sm font-bold uppercase tracking-wide mb-2 opacity-70">Savaş Günlüğü</div>
      <div id="log" class="text-xs max-h-48 overflow-auto leading-relaxed pr-1"></div>
    </div>

    <!-- BOTTOM HINT BAR -->
    <div id="hint" class="glass rounded-xl px-3 py-2 text-sm absolute left-1/2 -translate-x-1/2 bottom-4 z-[5000]">Hazır.</div>
  </main>

  <!-- FOOTER -->
  <footer class="glass w-full text-center text-xs py-2 opacity-70">Made with ❤️ on Leaflet • Demo oyun mekaniği (tek dosya)</footer>
</div>

<!-- HELP MODAL -->
<div id="helpModal" class="modal">
  <div class="glass rounded-2xl p-6 max-w-xl text-sm">
    <div class="text-lg font-bold mb-2">Nasıl Oynanır?</div>
    <ul class="list-disc pl-5 space-y-2">
      <li>Oyun başladığında aynı şehirde, fakat <b>biraz daha uzak</b> iki üs kurulur (siz ve AI).</li>
      <li><b>İnşa</b>: Tipi seçin ve haritada yer tıklayın. Kepçe gidip kurar (Fabrika 60sn, diğerleri 30sn).</li>
      <li><b>Üretim</b> bina üzerinden yapılır: <b>Üs</b>→Kepçe, <b>Kışla</b>→Asker, <b>Fabrika</b>→Tank, <b>Liman</b>→Gemi.</li>
      <li><b>Birim hareket</b>: Seç ve haritada tıkla. <b>Kara birimleri</b> denize gidemez; <b>Gemiler</b> karaya çıkamaz.</li>
      <li><b>Gelir</b>: Değirmen para, Rafineri petrol, Liman para üretimine %20 global bonus.</li>
      <li>Davranış: Agresif/Tut. Hız: 1x–100x.</li>
    </ul>
    <div class="mt-4 text-right"><button class="btn bg-white/10" onclick="document.getElementById('helpModal').classList.remove('show')">Kapat</button></div>
  </div>
</div>

<script>
(()=>{
  // --- WORLD RTS (Single-file) ---
  // Lightweight RTS core built on Leaflet. No external game engine.

  /* -------------------------- Map Setup -------------------------- */
  const map = L.map('map', { zoomControl:true, worldCopyJump:true, minZoom:2, maxZoom:18 });
  // Esri World Imagery (Satellite) — free, no key required
  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles \u00a9 Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community',
    noWrap:false, maxZoom:19
  }).addTo(map);

  // SVG overlay for attack beams
  const svgLayer = L.svg({ clickable:false }).addTo(map);
  const svg = (function ensureSVG(){
    let el = svgLayer._container;
    if(!el || el.tagName?.toLowerCase() !== 'svg'){
      el = svgLayer._container?.querySelector?.('svg') || document.createElementNS('http://www.w3.org/2000/svg','svg');
      (svgLayer._container || map.getPanes().overlayPane).appendChild(el);
    }
    return el;
  })();

  /* -------------------------- UI Refs -------------------------- */
  const moneyEl = document.getElementById('money');
  const oilEl = document.getElementById('oil');
  const excEl = document.getElementById('excCount');
  const soldierEl = document.getElementById('soldierCount');
  const tankEl = document.getElementById('tankCount');
  const shipEl = document.getElementById('shipCount');
  const hintEl = document.getElementById('hint');
  const queueEl = document.getElementById('queue');
  const logEl = document.getElementById('log');
  const prodPanel = document.getElementById('prodPanel');
  const helpBtn = document.getElementById('helpBtn');
  helpBtn.onclick = ()=> document.getElementById('helpModal').classList.add('show');
  document.getElementById('newGame').onclick = ()=>{ location.reload() };
  document.getElementById('runTests').onclick = ()=> runSelfTests();

  const speedRange = document.getElementById('speedRange');
  const speedLbl = document.getElementById('speedLbl');
  document.querySelectorAll('[data-speed]').forEach(b=> b.addEventListener('click',()=> setSpeed(+b.dataset.speed)));
  speedRange.addEventListener('input', ()=> setSpeed(+speedRange.value));

  const stanceBtn = document.getElementById('stanceBtn');
  stanceBtn.addEventListener('click', ()=>{
    playerStance = (playerStance==='aggressive')? 'hold' : 'aggressive';
    stanceBtn.textContent = playerStance==='aggressive'? 'Agresif' : 'Tut';
    stanceBtn.className = 'btn ' + (playerStance==='aggressive'? 'bg-emerald-500/15' : 'bg-yellow-500/20');
  });

  function setSpeed(v){ gameSpeed = Math.max(1, Math.min(100, v)); speedRange.value = String(gameSpeed); speedLbl.textContent = gameSpeed+'x'; hint('Hız: '+gameSpeed+'x'); }

  function hint(msg){ hintEl.textContent = msg }
  function log(msg){ const t = document.createElement('div'); t.textContent = msg; logEl.prepend(t); }

  /* -------------------------- Game Data -------------------------- */
  const LAND_SEEDS = [
    [41.0082,28.9784], // Istanbul
    [39.9208,32.8541], // Ankara
    [48.8566,2.3522],  // Paris
    [52.52,13.405],    // Berlin
    [40.7128,-74.0060],// NYC
    [34.0522,-118.2437], // LA
    [35.6762,139.6503], // Tokyo
    [19.4326,-99.1332], // Mexico City
    [31.2304,121.4737], // Shanghai
    [28.6139,77.2090], // Delhi
    [30.0444,31.2357], // Cairo
    [6.5244,3.3792],   // Lagos
    [-33.8688,151.2093], // Sydney
    [37.7749,-122.4194], // SF
    [-23.5505,-46.6333], // Sao Paulo
    [41.9028,12.4964], // Rome
    [50.1109,8.6821],  // Frankfurt
    [59.3293,18.0686], // Stockholm
    [1.3521,103.8198], // Singapore
    [35.6892,51.3890], // Tehran
    [41.015, 29.2],    // East of Istanbul
    [38.4237,27.1428], // Izmir
  ];

  // Başlangıç mesafesini biraz daha açtık (aynı şehir, ama daha uzak)
  const START = { CITY_ZOOM: 10, PLAYER_RADIUS: 3000, AI_RADIUS: 5500, SEPARATION_DEG: Math.PI * 0.9 };

  const COST = {
    mill:      { money:100, oil:0, build:30 },
    refinery:  { money:50,  oil:0, build:30 },
    port:      { money:200, oil:0, build:30 },
    factory:   { money:150, oil:50, build:60 },
    barracks:  { money:100, oil:0, build:30 },
    tank:      { money:80,  oil:40 },
    soldier:   { money:30,  oil:0 },
    excavator: { money:70,  oil:20 },
    ship:      { money:120, oil:60 },
  };

  const STATS = {
    kepce:   { hp:120, speed:18, range:0,   dps:0,  medium:'land' },
    soldier: { hp:60,  speed:22, range:45,  dps:10, medium:'land' },
    tank:    { hp:200, speed:16, range:80,  dps:25, medium:'land' },
    ship:    { hp:220, speed:20, range:90,  dps:18, medium:'water' },
    base:    { hp:800 },
    mill:    { hp:220 },
    refinery:{ hp:240 },
    port:    { hp:260 },
    factory: { hp:340 },
    barracks:{ hp:280 },
  };

  const RATES = {
    moneyPerMill: 3,
    oilPerRef: 2,
    tickSec: 3,
    portBonus: 0.20,
  }

  const LAYERS = { units:L.layerGroup().addTo(map), buildings:L.layerGroup().addTo(map) };

  function randInt(n){ return Math.floor(Math.random()*n) }
  function choose(arr){ return arr[randInt(arr.length)] }
  function distance(a,b){ return map.distance(a,b) }

  function latlngTowards(from, to, distMeters){
    const total = distance(from,to);
    if(total===0 || distMeters>=total) return to;
    const r = distMeters/total;
    const lat = from.lat + (to.lat - from.lat)*r;
    const lng = from.lng + (to.lng - from.lng)*r;
    return L.latLng(lat,lng);
  }

  function offsetDir(latlng, meters, angleRad){
    const d=meters, ang=angleRad;
    const lat = latlng.lat + (d*Math.cos(ang))/111320;
    const lng = latlng.lng + (d*Math.sin(ang))/(40075000*Math.cos(latlng.lat*Math.PI/180)/360);
    return L.latLng(lat,lng);
  }
  function offset(latlng, meters){ return offsetDir(latlng, meters, Math.random()*Math.PI*2); }

  /* -------------------------- Very Simple Land Mask (coarse) -------------------------- */
  // Amaç: Kara birimleri okyanusa tıklayınca gitmesin, gemiler okyanusta kalsın.
  // Basit kıta kutuları ile yaklaşık kontrol (kesin kıyı çizgisi değil — hafif hatalar olabilir).
  const LAND_BOXES = [
    // [minLat, minLng, maxLat, maxLng]
    [5,-168,83,-52],    // Kuzey Amerika (yaklaşık)
    [-56,-82,13,-34],   // Güney Amerika
    [35,-10,72,40],     // Avrupa
    [-35,-18,37,52],    // Afrika
    [5,26,81,180],      // Asya (yaklaşık)
    [-45,110,-10,160],  // Avustralya
    [59,-74,84,-12],    // Grönland
  ];
  function isLand(latlng){
    const {lat,lng} = latlng;
    for(const b of LAND_BOXES){ if(lat>=b[0] && lat<=b[2] && lng>=b[1] && lng<=b[3]) return true; }
    return false;
  }
  function canUnitGoTo(u, dest){
    const medium = STATS[u.unitType].medium || 'land';
    const land = isLand(dest);
    if(medium==='land') return land; // denize gitmesin
    if(medium==='water') return !land; // karaya çıkmasın
    return true;
  }

  /* -------------------------- Entities -------------------------- */
  let ENT_ID=1; const ENT_INDEX=new Map();
  const Side = { PLAYER:'player', AI:'ai' };

  class Entity{
    constructor(opts){ Object.assign(this, opts); this.id = ENT_ID++; this.dead=false; ENT_INDEX.set(this.id,this); }
  }

  class Unit extends Entity{
    constructor(opts){
      super(opts);
      this.hp = STATS[this.unitType].hp;
      this.speed = STATS[this.unitType].speed; // m/s
      this.range = STATS[this.unitType].range||0; // m
      this.dps = STATS[this.unitType].dps||0; // per sec
      this.medium = STATS[this.unitType].medium||'land';
      this.dest = null; this.target=null; this.moveVec=null;
      this.marker = createMarker(this, true);
    }
  }

  class Building extends Entity{
    constructor(opts){
      super(opts);
      this.hp = STATS[this.buildingType].hp;
      this.marker = createMarker(this, false);
    }
  }

  const player = { money:120, oil:50, units:[], buildings:[], base:null, ports:()=>player.buildings.filter(b=>b.buildingType==='port').length };
  const ai     = { money:120, oil:50, units:[], buildings:[], base:null, lastThink:0 };

  const selection = new Set();
  let buildMode=null; // selected building type
  let playerStance = 'aggressive'; // 'aggressive' | 'hold'

  function updateHUD(){
    moneyEl.textContent = Math.floor(player.money);
    oilEl.textContent = Math.floor(player.oil);
    const units = player.units;
    excEl.textContent = units.filter(u=>u.unitType==='kepce').length;
    soldierEl.textContent = units.filter(u=>u.unitType==='soldier').length;
    tankEl.textContent = units.filter(u=>u.unitType==='tank').length;
    shipEl.textContent = units.filter(u=>u.unitType==='ship').length;
  }

  function createMarker(ent, isUnit){
    const isPlayer = ent.side===Side.PLAYER;
    const html = `<div class="${isUnit?'unit':'building'} ${isPlayer?'player':'ai'} ${cssClass(ent)}">
      <div class="hpbar"><div class="hpfill" style="width:100%"></div></div>
    </div>`;
    const icon = L.divIcon({ className:'', html, iconSize:[ isUnit?22:28, isUnit?22:28 ] });
    const marker = L.marker(ent.pos, { icon, zIndexOffset:isUnit? 1000 : 500 }).addTo(isUnit? LAYERS.units : LAYERS.buildings);
    marker.on('click', (e)=> onMarkerClick(ent, e));
    marker.on('contextmenu', (e)=> onMarkerRightClick(ent, e));
    marker.on('dblclick', ()=> quickProduce(ent));
    return marker;
  }

  function cssClass(ent){
    if(ent.unitType){
      if(ent.unitType==='kepce') return 'kepce';
      if(ent.unitType==='soldier') return 'soldier';
      if(ent.unitType==='tank') return 'tank';
      if(ent.unitType==='ship') return 'ship';
    } else if(ent.buildingType){
      if(ent.isBase) return 'base';
      return ent.buildingType;
    }
    return 'neutral'
  }

  function setSelected(ent, val){
    const el = ent.marker.getElement()?.firstChild; // div.unit/building
    if(!el) return;
    if(val) { el.classList.add('sel'); selection.add(ent) }
    else { el.classList.remove('sel'); selection.delete(ent) }
    renderProductionPanel();
  }

  function clearSelection(){ [...selection].forEach(ent=> setSelected(ent,false)); renderProductionPanel(); }

  function onMarkerClick(ent, e){
    if(e.originalEvent.shiftKey){ setSelected(ent, !selection.has(ent)); }
    else { clearSelection(); setSelected(ent, true); }
  }

  function onMarkerRightClick(ent, e){ /* future: context menu */ }

  map.on('click', (e)=>{
    if(buildMode){
      const type = buildMode; buildMode=null; hint('Kepçe inşa için yola çıktı.');
      const job = { type, pos:e.latlng };
      enqueueBuildJob(player, job);
    } else if(selection.size>0){
      selection.forEach(ent=>{
        if(ent instanceof Unit){
          if(canUnitGoTo(ent, e.latlng)){ ent.dest = e.latlng; ent.target=null; }
          else { hint(`${ent.unitType==='ship'?'Gemi':'Kara birimi'} burada ilerleyemez.`); }
        }
      });
    }
  });

  map.on('contextmenu', (e)=>{ clearSelection(); hint('Seçim temizlendi.'); });

  function enqueueBuildJob(sideObj, job){
    const kepces = sideObj.units.filter(u=>u.unitType==='kepce');
    const free = kepces.find(k=>!k.job);
    if(free){ free.job = job; free.dest = job.pos; updateQueueUI(); }
    else { (sideObj.queue ||= []).push(job); updateQueueUI(); }
  }

  function updateQueueUI(){
    queueEl.innerHTML = '';
    const list = (player.units.filter(u=>u.unitType==='kepce').map(k=> k.job? `⛏️ ${labelOf(k.job.type)} kuruluyor` : '⏳ Boş') ).concat( (player.queue||[]).map(j=>`🧱 Sırada: ${labelOf(j.type)}`) );
    list.forEach(t=>{ const li=document.createElement('li'); li.textContent=t; queueEl.appendChild(li) });
  }

  function labelOf(type){
    const m={mill:'Değirmen', refinery:'Rafineri', port:'Liman', factory:'Tank Fabrikası', barracks:'Kışla', ship:'Gemi', soldier:'Asker', tank:'Tank', kepce:'Kepçe'}; return m[type]||type
  }

  /* -------------------------- Income -------------------------- */
  let incomeTimer=0;
  function incomeTick(dt){
    incomeTimer += dt; if(incomeTimer < RATES.tickSec) return; incomeTimer=0;
    const mills = player.buildings.filter(b=>b.buildingType==='mill').length;
    const refs  = player.buildings.filter(b=>b.buildingType==='refinery').length;
    const ports = player.ports();
    let moneyAdd = mills * RATES.moneyPerMill * (1 + ports*RATES.portBonus);
    let oilAdd = refs * RATES.oilPerRef;
    player.money += moneyAdd; player.oil += oilAdd;

    const amills = ai.buildings.filter(b=>b.buildingType==='mill').length;
    const arefs  = ai.buildings.filter(b=>b.buildingType==='refinery').length;
    const aports = ai.buildings.filter(b=>b.buildingType==='port').length;
    let amoneyAdd = amills * RATES.moneyPerMill * (1 + aports*RATES.portBonus);
    let aoilAdd = arefs * RATES.oilPerRef;
    ai.money += amoneyAdd; ai.oil += aoilAdd;

    updateHUD();
  }

  /* -------------------------- Combat -------------------------- */
  function inRange(u, v){ return distance(u.pos, v.pos) <= (u.range||0) }

  function dealDamage(attacker, target, dt){
    if(attacker.dps<=0) return;
    target.hp -= attacker.dps * dt;
    updateHPBar(target);
    if(target.hp <= 0) destroyEntity(target, attacker);
    if(Math.random()<.3) drawBeam(attacker.pos, target.pos);
  }

  function updateHPBar(ent){
    const el = ent.marker.getElement(); if(!el) return; const fill = el.querySelector('.hpfill');
    const maxHP = ent.unitType? STATS[ent.unitType].hp : STATS[ent.buildingType].hp;
    const pct = Math.max(0, Math.min(100, (ent.hp/maxHP)*100));
    fill.style.width = pct+'%';
    fill.style.background = pct<33? 'linear-gradient(90deg,#ef4444,#dc2626)': pct<66? 'linear-gradient(90deg,#f59e0b,#d97706)': 'linear-gradient(90deg,#22c55e,#16a34a)';
  }

  function drawBeam(a,b){
    if(!svg) return;
    const p1 = map.latLngToLayerPoint(a), p2 = map.latLngToLayerPoint(b);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',p1.x); line.setAttribute('y1',p1.y); line.setAttribute('x2',p2.x); line.setAttribute('y2',p2.y);
    line.setAttribute('class','beam');
    svg.appendChild(line);
    setTimeout(()=> line.remove(), 160);
  }

  function destroyEntity(ent, killer){
    ent.dead = true;
    if(ent.marker){ ent.marker.remove(); }
    if(ent.unitType){
      const arr = ent.side===Side.PLAYER? player.units : ai.units; const i = arr.indexOf(ent); if(i>=0) arr.splice(i,1);
    } else {
      const arr = ent.side===Side.PLAYER? player.buildings : ai.buildings; const i = arr.indexOf(ent); if(i>=0) arr.splice(i,1);
      if(ent.isBase){ if(ent.side===Side.PLAYER) endGame(false); else endGame(true); }
    }
    if(selection.has(ent)) selection.delete(ent);
    if(killer) log(`${killer.side==='player'?'Bizim':'AI'} ${killer.unitType||killer.buildingType} birimi ${ent.unitType||ent.buildingType} yok etti.`);
    updateHUD(); renderProductionPanel();
  }

  function endGame(win){
    const modal = document.getElementById('helpModal');
    const box = modal.querySelector('.glass');
    modal.classList.add('show');
    box.querySelector('.text-lg').textContent = win? 'Zafer!' : 'Yenilgi!';
    box.querySelector('ul').innerHTML = `<li>${win? 'AI üssünü yok ettiniz. Harika komutanlık!' : 'Üssünüz yok edildi. Tekrar deneyin!'}</li>`;
  }

  /* -------------------------- Game Init -------------------------- */
  function initGame(){
    // Aynı şehir, ama daha uzak yerleştirme
    const city = choose(LAND_SEEDS);
    const center = L.latLng(city[0], city[1]);
    const angle = Math.random() * Math.PI * 2;

    const pPos = offsetDir(center, START.PLAYER_RADIUS, angle);
    const aPos = offsetDir(center, START.AI_RADIUS, angle + START.SEPARATION_DEG);

    const pBase = new Building({ side:Side.PLAYER, pos:pPos, buildingType:'base', isBase:true });
    const aBase = new Building({ side:Side.AI,     pos:aPos, buildingType:'base', isBase:true });
    player.base = pBase; ai.base = aBase; player.buildings.push(pBase); ai.buildings.push(aBase);

    const pKep = new Unit({ side:Side.PLAYER, pos:offset(pBase.pos, 120), unitType:'kepce' }); player.units.push(pKep);
    const aKep = new Unit({ side:Side.AI,     pos:offset(aBase.pos, 120), unitType:'kepce' }); ai.units.push(aKep);

    map.setView(center, START.CITY_ZOOM);
    updateHUD();
    updateQueueUI();
    hint('Aynı şehirde, ama daha uzak başlangıç! Bina seçerek üretim yapın.');

    aiThink(0,true);
  }

  /* -------------------------- Build & Train (contextual) -------------------------- */
  const buildBtns = document.querySelectorAll('[data-build]');
  buildBtns.forEach(btn=> btn.addEventListener('click',()=>{
    const type = btn.dataset.build;
    if(player.money < (COST[type].money||0) || player.oil < (COST[type].oil||0)) { hint('Yetersiz kaynak.'); return; }
    player.money -= (COST[type].money||0); player.oil -= (COST[type].oil||0); updateHUD();
    buildMode = type; hint(`${labelOf(type)} için konum seçin.`);
  }));

  function renderProductionPanel(){
    // Yalnızca oyuncu binası tek seçiliyken üretim göster
    const items = [...selection].filter(x=> x instanceof Building && x.side===Side.PLAYER);
    prodPanel.innerHTML = '';
    if(items.length!==1){ prodPanel.innerHTML = '<div class="opacity-60">Bir bina seçin…</div>'; return; }
    const b = items[0];
    const wrap = document.createElement('div');
    function addBtn(title, sub, kind){
      const btn = document.createElement('button');
      btn.className = 'btn bg-white/5 hover:bg-white/10 w-full justify-between';
      btn.innerHTML = `<span>${title}</span><span class="opacity-70 text-xs">${sub}</span>`;
      btn.onclick = ()=> produceFromBuilding(b, kind);
      wrap.appendChild(btn);
    }
    if(b.isBase){ addBtn('⛏️ Kepçe Çıkar', `(💰${COST.excavator.money} + 🛢️${COST.excavator.oil})`, 'kepce'); }
    if(b.buildingType==='barracks'){ addBtn('🪖 Asker Çıkar', `(💰${COST.soldier.money})`, 'soldier'); }
    if(b.buildingType==='factory'){ addBtn('🛡️ Tank Çıkar', `(💰${COST.tank.money} + 🛢️${COST.tank.oil})`, 'tank'); }
    if(b.buildingType==='port'){ addBtn('🚢 Gemi Çıkar', `(💰${COST.ship.money} + 🛢️${COST.ship.oil})`, 'ship'); }
    if(!wrap.childNodes.length){ prodPanel.innerHTML = '<div class="opacity-60">Bu binadan üretim yok.</div>'; }
    else prodPanel.appendChild(wrap);
  }

  function quickProduce(ent){
    if(!(ent instanceof Building) || ent.side!==Side.PLAYER) return;
    if(ent.isBase) return produceFromBuilding(ent,'kepce');
    if(ent.buildingType==='barracks') return produceFromBuilding(ent,'soldier');
    if(ent.buildingType==='factory') return produceFromBuilding(ent,'tank');
    if(ent.buildingType==='port') return produceFromBuilding(ent,'ship');
  }

  function produceFromBuilding(building, kind){
    // Kaynak kontrolü
    const need = COST[kind==='kepce'?'excavator':kind];
    if(player.money < (need.money||0) || player.oil < (need.oil||0)) { hint('Yetersiz kaynak.'); return; }
    player.money -= (need.money||0); player.oil -= (need.oil||0); updateHUD();

    // Çıkış pozisyonu: binanın etrafında uygun (kara/su) nokta ara
    const pos = findSpawnAround(building.pos, kind);
    if(!pos){ hint('Çıkış noktası bulunamadı (sahil gerekli olabilir).'); return; }

    const u = new Unit({ side:Side.PLAYER, pos, unitType: kind });
    player.units.push(u); updateHUD();
    hint(`${labelOf(kind)} üretildi.`);
  }

  function findSpawnAround(origin, kind){
    const wantLand = (kind!=='ship');
    for(let r=30; r<=200; r+=20){
      for(let k=0;k<10;k++){
        const ang = Math.random()*Math.PI*2;
        const p = offsetDir(origin, r, ang);
        if( (wantLand && isLand(p)) || (!wantLand && !isLand(p)) ) return p;
      }
    }
    // son çare: origin'in kendisi
    if((wantLand && isLand(origin)) || (!wantLand && !isLand(origin))) return origin;
    return null;
  }

  /* -------------------------- Kepçe Build Flow -------------------------- */
  function tickKepce(dt, u, owner){
    moveUnit(dt, u);
    if(u.job && u.dest==null){
      if(!u.buildTask){
        const type = u.job.type;
        const b = new Building({ side:u.side, pos:u.job.pos, buildingType:type });
        b.buildProgress = 0; b.buildNeeded = COST[type].build; 
        b.underConstruction = true;
        b.marker.getElement().querySelector('.hpbar').insertAdjacentHTML('beforebegin','<div class="buildbar"><div class="buildfill" style="width:0%"></div></div>');
        u.buildTask = b; 
        (owner.buildings).push(b);
      } else {
        u.buildTask.buildProgress += dt;
        const pct = Math.min(100, (u.buildTask.buildProgress/u.buildTask.buildNeeded)*100);
        const el = u.buildTask.marker.getElement(); if(el){ const f = el.querySelector('.buildfill'); if(f) f.style.width=pct+'%'; }
        if(u.buildTask.buildProgress>=u.buildTask.buildNeeded){
          u.buildTask.underConstruction=false;
          const el2 = u.buildTask.marker.getElement(); if(el2){ const bb = el2.querySelector('.buildbar'); if(bb) bb.remove(); }
          log(`${owner===player?'Bizim':'AI'} ${labelOf(u.job.type)} tamamlandı.`);
          u.job = null; u.buildTask=null;
          if(owner.queue && owner.queue.length>0){ u.job = owner.queue.shift(); u.dest = u.job.pos; }
          updateQueueUI(); updateHUD();
        }
      }
    }
  }

  function moveUnit(dt, u){
    if(!u.dest) return;
    // Hedef ortam kontrolü
    if(!canUnitGoTo(u, u.dest)){ u.dest = null; return; }
    const step = u.speed * dt; 
    const next = latlngTowards(u.pos, u.dest, step);
    u.pos = next; u.marker.setLatLng(u.pos);
    if(distance(u.pos, u.dest) < 4){ u.dest=null }
  }

  /* -------------------------- Combat & AI Targeting -------------------------- */
  function tickCombat(dt, sideObj, enemySide){
    const units = sideObj.units;
    const enemies = enemySide.units.concat(enemySide.buildings);

    for(const u of units){
      moveUnit(dt, u);
      if(u.dps>0){
        if(sideObj===player && playerStance==='hold'){
          // HOLD: ateş eder ama kovalamaz
          if(u.target && inRange(u, u.target)) dealDamage(u, u.target, dt);
          else {
            const immediate = acquireTargetInRange(u, enemies);
            if(immediate) { u.target = immediate; dealDamage(u, u.target, dt); }
          }
          continue; // default agresifi atla
        }

        // AGGRESSIVE (varsayılan) + AI
        if(!u.target || u.target.dead){ u.target = acquireTarget(u, enemies); }
        else if(distance(u.pos, u.target.pos) > (u.range*1.1)){ u.dest = u.target.pos; }
        if(u.target && inRange(u, u.target)){
          dealDamage(u, u.target, dt);
        }
      }
    }
  }

  function acquireTarget(u, enemies){
    let best=null, bestD=Infinity;
    for(const e of enemies){ if(e.dead) continue; const d=distance(u.pos,e.pos); if(d<bestD){ best=e; bestD=d; } }
    return best;
  }
  function acquireTargetInRange(u, enemies){
    let best=null, bestD=Infinity; const R=u.range||0;
    for(const e of enemies){ if(e.dead) continue; const d=distance(u.pos,e.pos); if(d<=R && d<bestD){ best=e; bestD=d; } }
    return best;
  }

  /* -------------------------- AI -------------------------- */
  function aiThink(dt, forceSeed=false){
    ai.lastThink += dt;
    if(forceSeed || ai.lastThink>5){
      ai.lastThink=0;
      const hasMill = ai.buildings.some(b=>b.buildingType==='mill');
      const hasRef  = ai.buildings.some(b=>b.buildingType==='refinery');
      const hasBarr = ai.buildings.some(b=>b.buildingType==='barracks');
      const hasFac  = ai.buildings.some(b=>b.buildingType==='factory');
      const hasPort = ai.buildings.some(b=>b.buildingType==='port');

      if(!hasMill && ai.money>=COST.mill.money) { ai.money-=COST.mill.money; enqueueBuildJob(ai, {type:'mill', pos: offset(ai.base.pos, 1400) }); }
      else if(!hasRef && ai.money>=COST.refinery.money) { ai.money-=COST.refinery.money; enqueueBuildJob(ai, {type:'refinery', pos: offset(ai.base.pos, 1600) }); }
      else if(!hasBarr && ai.money>=COST.barracks.money) { ai.money-=COST.barracks.money; enqueueBuildJob(ai, {type:'barracks', pos: offset(ai.base.pos, 1200) }); }
      else if(!hasFac && ai.money>=COST.factory.money && ai.oil>=COST.factory.oil) { ai.money-=COST.factory.money; ai.oil-=COST.factory.oil; enqueueBuildJob(ai, {type:'factory', pos: offset(ai.base.pos, 1800) }); }
      else if(!hasPort && ai.money>=COST.port.money) { ai.money-=COST.port.money; enqueueBuildJob(ai, {type:'port', pos: offset(ai.base.pos, 2200) }); }

      const aiBarr = ai.buildings.find(b=>b.buildingType==='barracks');
      const aiFac  = ai.buildings.find(b=>b.buildingType==='factory');
      const aiPort = ai.buildings.find(b=>b.buildingType==='port');

      if(aiBarr && ai.money>=COST.soldier.money && Math.random()<.7){ ai.money-=COST.soldier.money; aiSpawnFromBuilding('soldier', aiBarr); }
      if(aiFac && ai.money>=COST.tank.money && ai.oil>=COST.tank.oil && Math.random()<.5){ ai.money-=COST.tank.money; ai.oil-=COST.tank.oil; aiSpawnFromBuilding('tank', aiFac); }
      if(aiPort && ai.money>=COST.ship.money && ai.oil>=COST.ship.oil && Math.random()<.3){ ai.money-=COST.ship.money; ai.oil-=COST.ship.oil; aiSpawnFromBuilding('ship', aiPort); }

      // Basit saldırı
      const army = ai.units.filter(u=>u.dps>0);
      if(army.length>=6){ const t = acquireTarget({pos:ai.base.pos}, player.units.concat(player.buildings)); if(t){ army.forEach(u=>{ if(canUnitGoTo(u,t.pos)) u.dest=t.pos; }); log('AI saldırı başlattı!'); } }
    }
  }

  function aiSpawnFromBuilding(kind, b){
    const pos = findSpawnAround(b.pos, kind); if(!pos) return;
    const u = new Unit({ side:Side.AI, pos, unitType: kind });
    ai.units.push(u);
  }

  /* -------------------------- Game Loop with Speed -------------------------- */
  let last = performance.now();
  let gameSpeed = 1; setSpeed(1);
  const FIXED_STEP = 0.02; // 50 sim steps per second
  const MAX_STEPS = 300;   // güvenlik limiti (100x hızda da yeterli)
  let accumulator = 0;

  function step(dt){
    // kepçe logic
    player.units.filter(u=>u.unitType==='kepce').forEach(u=> tickKepce(dt, u, player));
    ai.units.filter(u=>u.unitType==='kepce').forEach(u=> tickKepce(dt, u, ai));

    // movement + combat
    tickCombat(dt, player, ai);
    tickCombat(dt, ai, player);

    // economy + ai
    incomeTick(dt);
    aiThink(dt);
  }

  function loop(now){
    const baseDt = Math.min(0.1, (now-last)/1000); // tab değişince dev adımları kıs
    last = now;
    accumulator += baseDt * gameSpeed;

    let steps=0;
    while(accumulator >= FIXED_STEP && steps < MAX_STEPS){
      step(FIXED_STEP);
      accumulator -= FIXED_STEP;
      steps++;
    }

    requestAnimationFrame(loop);
  }

  /* -------------------------- Self Tests (runtime) -------------------------- */
  function runSelfTests(){
    try {
      console.assert(svg instanceof SVGSVGElement, 'SVG container is ready');
      drawBeam(map.getCenter(), map.getCenter());
      log('🧪 Test: SVG/beam oluşturma ✅');
    } catch(e){ log('🧪 Test: SVG/beam oluşturma ❌ ' + e.message); console.error(e); }

    try {
      const prev = gameSpeed; setSpeed(10); console.assert(gameSpeed===10, 'Speed set to 10'); setSpeed(prev);
      log('🧪 Test: Hız kontrol ✅');
    } catch(e){ log('🧪 Test: Hız kontrol ❌ ' + e.message); console.error(e); }

    try {
      // Kara birimi suya gidememeli
      const s = new Unit({ side:Side.PLAYER, pos:L.latLng(41,29), unitType:'soldier' });
      player.units.push(s);
      const ocean = L.latLng(0,-30); // Atlantik ortası
      const ok = canUnitGoTo(s, ocean);
      console.assert(!ok, 'Kara birimi okyanusa gitmemeli');
      s.marker.remove(); player.units.pop();
      log('🧪 Test: Kara/Su kısıtı ✅');
    } catch(e){ log('🧪 Test: Kara/Su kısıtı ❌ ' + e.message); console.error(e); }

    try {
      const d = distance(player.base.pos, ai.base.pos);
      console.assert(d > 3000 && d < 12000, 'Üsler aynı şehir içinde ama daha uzak (3–12km)');
      log('🧪 Test: Başlangıç mesafesi ✅ ('+Math.round(d)+'m)');
    } catch(e){ log('🧪 Test: Başlangıç mesafesi ❌ ' + e.message); console.error(e); }
  }

  /* -------------------------- Start -------------------------- */
  initGame();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
